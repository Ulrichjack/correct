# üéØ GUIDE COMPLET - APPLICATION EGO IA BLUE LOCK
## Version D√©taill√©e √âtape par √âtape avec Tests

---

## üìä VUE D'ENSEMBLE DU PROJET

**Ce qu'on va cr√©er :**
Une application intelligente o√π Ego Jinpachi (style Blue Lock) vous accompagne comme coach de d√©veloppement personnel. Il suit vos statistiques, vous donne des missions, vous rappelle vos objectifs, analyse vos soumissions de code/projets et √©volue avec vous.

**Dur√©e totale : 2-3 semaines (10-15 heures par semaine)**

**Technologies utilis√©es :**
- Backend : FastAPI (Python)
- IA : Groq API (gratuit, 6000 requ√™tes/jour)
- Base de donn√©es : SQLite (simple, pas de serveur)
- Frontend : HTML/CSS/JavaScript (simple au d√©but)
- H√©bergement : Render.com (gratuit)

**Architecture globale :**
```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  FRONTEND (Interface Web)               ‚îÇ
‚îÇ  - Chat avec Ego                        ‚îÇ
‚îÇ  - Dashboard de stats                   ‚îÇ
‚îÇ  - Liste des missions                   ‚îÇ
‚îÇ  - Soumission de r√©sultats              ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
               ‚îÇ HTTP/WebSocket
               ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  BACKEND (FastAPI - Python)             ‚îÇ
‚îÇ  - API REST                             ‚îÇ
‚îÇ  - Gestion des sessions                 ‚îÇ
‚îÇ  - Logique m√©tier                       ‚îÇ
‚îî‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
   ‚îÇ        ‚îÇ         ‚îÇ
   ‚ñº        ‚ñº         ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ DB  ‚îÇ ‚îÇGroq ‚îÇ ‚îÇScheduler ‚îÇ
‚îÇSQLite‚îÇ ‚îÇ API ‚îÇ ‚îÇ(Rappels) ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

---

# üìÖ SEMAINE 1 : FONDATIONS ET BACKEND

## JOUR 1 : INSTALLATION ET CONFIGURATION (2-3 heures)

### üéØ Objectif du jour
Installer tous les outils n√©cessaires et cr√©er la structure de base du projet.

---

### ‚úÖ √âtape 1.1 : V√©rifier Python

**Ce que tu dois faire :**
1. Ouvrir le terminal/invite de commandes
2. Taper : `python --version` ou `python3 --version`
3. V√©rifier que tu as Python 3.10 ou plus r√©cent

**Comment savoir que √ßa marche :**
- Tu vois affich√© : "Python 3.10.X" ou version sup√©rieure
- Si ce n'est pas le cas, t√©l√©charge Python depuis python.org

**Pourquoi c'est important :**
- FastAPI et les biblioth√®ques modernes n√©cessitent Python 3.10+
- Les fonctionnalit√©s async/await dont on a besoin sont dans cette version

---

### ‚úÖ √âtape 1.2 : Cr√©er le dossier projet

**Ce que tu dois faire :**
1. Cr√©er un dossier appel√© "ego-ia-bluelock" sur ton ordinateur
2. Ouvrir ce dossier dans ton √©diteur de code (VSCode, PyCharm, etc.)

**Commandes terminal :**
```bash
mkdir ego-ia-bluelock
cd ego-ia-bluelock
```

**Comment savoir que √ßa marche :**
- Le dossier existe et est ouvert dans ton √©diteur
- Ton terminal est positionn√© dans ce dossier (tu vois le nom dans le chemin)

---

### ‚úÖ √âtape 1.3 : Cr√©er environnement virtuel Python

**Ce que tu dois faire :**
Cr√©er un environnement isol√© pour ton projet.

**Commandes selon ton syst√®me :**

**Windows :**
```bash
python -m venv venv
venv\Scripts\activate
```

**Mac/Linux :**
```bash
python3 -m venv venv
source venv/bin/activate
```

**Comment savoir que √ßa marche :**
- Un dossier "venv" appara√Æt dans ton projet
- Tu vois "(venv)" au d√©but de ta ligne de commande
- Exemple : `(venv) C:\ego-ia-bluelock>`

**Pourquoi c'est important :**
- Isole ton projet des autres projets Python
- √âvite les conflits de versions de biblioth√®ques
- Facilite le d√©ploiement

**Probl√®mes courants :**
- Si "python" ne marche pas, essaie "python3"
- Si activation √©choue sur Windows, ouvre PowerShell en admin et tape :
  ```bash
  Set-ExecutionPolicy -ExecutionPolicy RemoteSigned -Scope CurrentUser
  ```

---

### ‚úÖ √âtape 1.4 : Cr√©er la structure des dossiers

**Ce que tu dois faire :**
Cr√©er l'arborescence compl√®te du projet.

**Structure √† cr√©er :**
```
ego-ia-bluelock/
‚îú‚îÄ‚îÄ app/
‚îÇ   ‚îú‚îÄ‚îÄ __init__.py
‚îÇ   ‚îú‚îÄ‚îÄ main.py
‚îÇ   ‚îú‚îÄ‚îÄ config.py
‚îÇ   ‚îú‚îÄ‚îÄ database.py
‚îÇ   ‚îú‚îÄ‚îÄ models.py
‚îÇ   ‚îú‚îÄ‚îÄ schemas.py
‚îÇ   ‚îú‚îÄ‚îÄ api/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ __init__.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ routes.py
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ dependencies.py
‚îÇ   ‚îî‚îÄ‚îÄ services/
‚îÇ       ‚îú‚îÄ‚îÄ __init__.py
‚îÇ       ‚îú‚îÄ‚îÄ ai_service.py
‚îÇ       ‚îú‚îÄ‚îÄ stats_service.py
‚îÇ       ‚îú‚îÄ‚îÄ mission_service.py
‚îÇ       ‚îî‚îÄ‚îÄ notification_service.py
‚îú‚îÄ‚îÄ frontend/
‚îÇ   ‚îú‚îÄ‚îÄ index.html
‚îÇ   ‚îú‚îÄ‚îÄ styles.css
‚îÇ   ‚îú‚îÄ‚îÄ app.js
‚îÇ   ‚îî‚îÄ‚îÄ assets/
‚îú‚îÄ‚îÄ uploads/
‚îÇ   ‚îú‚îÄ‚îÄ screenshots/
‚îÇ   ‚îî‚îÄ‚îÄ files/
‚îú‚îÄ‚îÄ tests/
‚îÇ   ‚îú‚îÄ‚îÄ __init__.py
‚îÇ   ‚îú‚îÄ‚îÄ test_api.py
‚îÇ   ‚îî‚îÄ‚îÄ test_services.py
‚îú‚îÄ‚îÄ .env
‚îú‚îÄ‚îÄ .gitignore
‚îú‚îÄ‚îÄ requirements.txt
‚îú‚îÄ‚îÄ README.md
‚îî‚îÄ‚îÄ run.py
```

**Commandes pour cr√©er rapidement (Linux/Mac) :**
```bash
mkdir -p app/api app/services frontend/assets uploads/screenshots uploads/files tests
touch app/__init__.py app/main.py app/config.py app/database.py
touch app/models.py app/schemas.py
touch app/api/__init__.py app/api/routes.py app/api/dependencies.py
touch app/services/__init__.py app/services/ai_service.py
touch app/services/stats_service.py app/services/mission_service.py
touch app/services/notification_service.py
touch frontend/index.html frontend/styles.css frontend/app.js
touch tests/__init__.py tests/test_api.py tests/test_services.py
touch .env .gitignore requirements.txt README.md run.py
```

**Sur Windows (PowerShell) :**
Cr√©er les dossiers et fichiers un par un via l'explorateur ou l'√©diteur de code.

**Comment savoir que √ßa marche :**
- Tu vois tous ces dossiers et fichiers dans ton √©diteur
- La structure est identique au sch√©ma ci-dessus

**Pourquoi cette structure :**
- `app/` : tout le code backend
- `app/api/` : routes et endpoints de l'API
- `app/services/` : logique m√©tier (IA, stats, missions)
- `frontend/` : interface utilisateur
- `uploads/` : fichiers upload√©s par l'utilisateur
- `tests/` : tests automatis√©s

---

### ‚úÖ √âtape 1.5 : Cr√©er requirements.txt

**Ce que tu dois faire :**
Lister toutes les biblioth√®ques Python n√©cessaires.

**Contenu du fichier `requirements.txt` :**
```txt
# Framework web
fastapi==0.104.1
uvicorn[standard]==0.24.0

# Base de donn√©es
sqlalchemy==2.0.23
aiosqlite==0.19.0

# IA et API externe
groq==0.4.1

# Validation de donn√©es
pydantic==2.5.0
pydantic-settings==2.1.0

# Upload de fichiers
python-multipart==0.0.6
aiofiles==23.2.1

# Variables d'environnement
python-dotenv==1.0.0

# Scheduler pour rappels
apscheduler==3.10.4

# S√©curit√©
python-jose[cryptography]==3.3.0
passlib[bcrypt]==1.7.4

# Utils
python-dateutil==2.8.2
```

**Ce que tu dois faire :**
1. Ouvrir le fichier requirements.txt
2. Copier-coller le contenu ci-dessus
3. Sauvegarder

**Comment savoir que √ßa marche :**
- Le fichier existe √† la racine du projet
- Il contient exactement ces lignes

**Pourquoi ces biblioth√®ques :**
- **fastapi** : framework web moderne et rapide
- **uvicorn** : serveur ASGI pour FastAPI
- **sqlalchemy** : ORM pour g√©rer la base de donn√©es
- **groq** : client API pour l'IA Groq
- **pydantic** : validation automatique des donn√©es
- **apscheduler** : pour les rappels automatiques
- **aiofiles** : gestion asynchrone des fichiers

---

### ‚úÖ √âtape 1.6 : Installer les d√©pendances

**Ce que tu dois faire :**
Installer toutes les biblioth√®ques list√©es dans requirements.txt.

**Commande :**
```bash
pip install -r requirements.txt
```

**Ce qui va se passer :**
- Plein de lignes d√©filent dans le terminal
- Chaque biblioth√®que est t√©l√©charg√©e et install√©e
- √áa prend 3-5 minutes

**Comment savoir que √ßa marche :**
- Tu vois √† la fin : "Successfully installed..." suivi de la liste des packages
- Aucune erreur rouge
- La commande se termine sans probl√®me

**Probl√®mes courants :**
- **"pip not found"** : v√©rifie que venv est activ√©
- **Erreur de compilation** : installe les outils de build
  - Windows : Visual Studio Build Tools
  - Mac : Xcode Command Line Tools (`xcode-select --install`)
  - Linux : `sudo apt-get install build-essential`

---

### ‚úÖ √âtape 1.7 : Obtenir la cl√© API Groq

**Ce que tu dois faire :**
Cr√©er un compte Groq et obtenir ta cl√© API gratuite.

**√âtapes d√©taill√©es :**
1. Aller sur https://console.groq.com
2. Cliquer sur "Sign Up" ou "Get Started"
3. Cr√©er un compte avec ton email
4. V√©rifier ton email et te connecter
5. Dans le dashboard, aller dans "API Keys"
6. Cliquer sur "Create API Key"
7. Donner un nom √† la cl√© (ex: "ego-ia-dev")
8. Copier la cl√© (elle commence par "gsk_...")

**TR√àS IMPORTANT :**
- Copie imm√©diatement la cl√© dans un fichier temporaire
- Tu ne pourras plus la revoir apr√®s avoir ferm√© la popup
- Ne la partage JAMAIS publiquement

**Comment savoir que √ßa marche :**
- Tu as une cl√© qui ressemble √† : `gsk_xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx`
- Elle fait environ 50-60 caract√®res

**Limites gratuites de Groq :**
- 6000 requ√™tes par jour (largement suffisant)
- Mod√®les disponibles : Llama 3.1, Mixtral, Gemma
- Tr√®s rapide (plus rapide que GPT)

---

### ‚úÖ √âtape 1.8 : Cr√©er le fichier .env

**Ce que tu dois faire :**
Cr√©er un fichier pour stocker les variables sensibles.

**Contenu du fichier `.env` :**
```env
# API Keys
GROQ_API_KEY=gsk_votre_cle_ici_remplacer

# Database
DATABASE_URL=sqlite+aiosqlite:///./ego_bluelock.db

# Security
SECRET_KEY=votre_secret_key_random_changez_moi

# App Config
APP_NAME=Ego IA Blue Lock
DEBUG=True
ENVIRONMENT=development

# AI Config
AI_MODEL=llama-3.1-70b-versatile
AI_TEMPERATURE=0.3
MAX_TOKENS=1000

# Server
HOST=0.0.0.0
PORT=8000
```

**Ce que tu dois modifier :**
1. Remplacer `gsk_votre_cle_ici_remplacer` par ta vraie cl√© Groq
2. Remplacer `votre_secret_key_random_changez_moi` par une cha√Æne al√©atoire
   - Pour g√©n√©rer une cl√© secr√®te s√©curis√©e, utilise :
   ```python
   import secrets
   print(secrets.token_urlsafe(32))
   ```

**Comment savoir que √ßa marche :**
- Le fichier .env existe √† la racine du projet
- Il contient ta vraie cl√© Groq
- Les valeurs sont correctement format√©es (pas de guillemets)

**Pourquoi c'est important :**
- S√©pare les secrets du code
- Facilite le changement de configuration
- S√©curise tes cl√©s API

**ATTENTION :**
- Ne jamais commit le .env sur Git
- Ajouter .env dans .gitignore

---

### ‚úÖ √âtape 1.9 : Cr√©er le fichier .gitignore

**Ce que tu dois faire :**
Emp√™cher certains fichiers d'√™tre versionn√©s sur Git.

**Contenu du fichier `.gitignore` :**
```gitignore
# Python
venv/
__pycache__/
*.pyc
*.pyo
*.pyd
.Python
*.so
*.egg
*.egg-info/
dist/
build/

# Environment
.env
.env.local
.env.*.local

# Database
*.db
*.sqlite
*.sqlite3

# Uploads
uploads/
!uploads/.gitkeep

# IDE
.vscode/
.idea/
*.swp
*.swo
*~

# OS
.DS_Store
Thumbs.db

# Logs
*.log
logs/

# Tests
.coverage
htmlcov/
.pytest_cache/
```

**Comment savoir que √ßa marche :**
- Le fichier .gitignore existe
- Git ignore automatiquement les fichiers list√©s

**Pourquoi c'est important :**
- Prot√®ge tes secrets (.env)
- √âvite de commit des fichiers temporaires
- R√©duit la taille du d√©p√¥t

---

### ‚úÖ √âtape 1.10 : Test d'installation

**Ce que tu dois faire :**
V√©rifier que tout est correctement install√©.

**Commandes de test :**
```bash
# V√©rifier que Python trouve FastAPI
python -c "import fastapi; print('FastAPI OK')"

# V√©rifier que Groq est install√©
python -c "import groq; print('Groq OK')"

# V√©rifier que SQLAlchemy est install√©
python -c "import sqlalchemy; print('SQLAlchemy OK')"

# V√©rifier la version de Python
python --version
```

**Comment savoir que √ßa marche :**
- Chaque commande affiche "XXX OK"
- Aucune erreur "ModuleNotFoundError"
- Python version 3.10+

**Si un import √©choue :**
1. V√©rifie que venv est activ√© (tu vois "(venv)")
2. R√©installe : `pip install -r requirements.txt`
3. Red√©marre ton terminal

---

### ‚úÖ √âtape 1.11 : Cr√©er README.md

**Ce que tu dois faire :**
Documenter ton projet pour toi et les autres.

**Contenu du fichier `README.md` :**
```markdown
# üéØ Ego IA Blue Lock

Application intelligente de coaching de d√©veloppement inspir√©e de Blue Lock.

## üìã Fonctionnalit√©s

- ü§ñ IA avec personnalit√© Ego Jinpachi
- üìä Suivi de statistiques en temps r√©el
- üéØ Syst√®me de missions et objectifs
- ‚è∞ Rappels automatiques
- üìà Analyse de vos soumissions
- üèÜ Gamification et progression

## üöÄ Installation

1. Cloner le projet
2. Cr√©er un environnement virtuel : `python -m venv venv`
3. Activer l'environnement : `source venv/bin/activate` (Mac/Linux) ou `venv\Scripts\activate` (Windows)
4. Installer les d√©pendances : `pip install -r requirements.txt`
5. Cr√©er un fichier `.env` avec ta cl√© Groq API
6. Lancer l'application : `python run.py`

## üîë Configuration

Copier `.env.example` vers `.env` et configurer :
- GROQ_API_KEY : ta cl√© API Groq
- SECRET_KEY : une cl√© secr√®te al√©atoire

## üìö Technologies

- Backend : FastAPI (Python)
- IA : Groq API
- Base de donn√©es : SQLite
- Frontend : HTML/CSS/JavaScript

## üë§ Auteur

Votre nom
```

**Comment savoir que √ßa marche :**
- Le fichier README.md existe √† la racine
- Il explique clairement le projet

---

## JOUR 2 : CONFIGURATION ET MOD√àLES DE DONN√âES (4-5 heures)

### üéØ Objectif du jour
Cr√©er la configuration de l'application et d√©finir la structure de la base de donn√©es.

---

### ‚úÖ √âtape 2.1 : Cr√©er app/config.py

**Ce que ce fichier doit faire :**
- Charger les variables du fichier .env
- Fournir une configuration centralis√©e
- Valider les variables d'environnement

**Contenu attendu :**
1. Une classe `Settings` qui h√©rite de `BaseSettings` (Pydantic)
2. D√©finition de toutes les variables d'environnement :
   - `groq_api_key` : la cl√© API Groq
   - `database_url` : URL de connexion SQLite
   - `secret_key` : cl√© pour s√©curit√©
   - `app_name`, `debug`, `environment`
   - `ai_model`, `ai_temperature`, `max_tokens`
3. Une fonction `get_settings()` avec cache (`@lru_cache`)

**Comment √©crire ce fichier :**
1. Importer `BaseSettings` de `pydantic_settings`
2. Importer `lru_cache` de `functools`
3. Cr√©er la classe avec tous les attributs
4. Ajouter `class Config` avec `env_file = ".env"`
5. Cr√©er la fonction getter avec d√©corateur cache

**Comment savoir que √ßa marche :**
- Le fichier existe dans app/
- Tu peux l'importer sans erreur : `from app.config import get_settings`
- `get_settings().groq_api_key` retourne ta cl√©

**Test rapide :**
```bash
python -c "from app.config import get_settings; print(get_settings().app_name)"
```
Devrait afficher : "Ego IA Blue Lock"

---

### ‚úÖ √âtape 2.2 : Cr√©er app/models.py (Mod√®les de base de donn√©es)

**Ce que ce fichier doit faire :**
D√©finir la structure des tables de la base de donn√©es.

**Tables √† cr√©er :**

**1. Table User (Utilisateur) :**
- id : identifiant unique (entier, cl√© primaire)
- username : nom d'utilisateur (texte, unique)
- created_at : date de cr√©ation (datetime)
- niveau : niveau Blue Lock (entier, d√©faut 0)
- total_points : points accumul√©s (entier, d√©faut 0)
- projets_termines : nombre de projets finis (entier, d√©faut 0)
- streak_actuel : s√©rie de jours cons√©cutifs (entier, d√©faut 0)
- meilleur_streak : record de streak (entier, d√©faut 0)
- derniere_activite : derni√®re connexion (datetime)
- competences : liste de comp√©tences d√©bloqu√©es (texte JSON)

**2. Table Mission :**
- id : identifiant unique
- user_id : r√©f√©rence √† User (cl√© √©trang√®re)
- titre : nom de la mission (texte)
- description : d√©tails (texte)
- points_recompense : points √† gagner (entier)
- statut : active/completed/failed (texte)
- deadline : date limite (datetime, optionnel)
- created_at : date de cr√©ation (datetime)
- completed_at : date de compl√©tion (datetime, optionnel)

**3. Table Conversation :**
- id : identifiant unique
- user_id : r√©f√©rence √† User (cl√© √©trang√®re)
- message_user : message de l'utilisateur (texte)
- reponse_ego : r√©ponse d'Ego (texte)
- timestamp : horodatage (datetime)
- contexte : contexte de la conversation (texte JSON)

**4. Table Soumission :**
- id : identifiant unique
- user_id : r√©f√©rence √† User (cl√© √©trang√®re)
- mission_id : r√©f√©rence √† Mission (cl√© √©trang√®re, optionnel)
- titre : titre de la soumission (texte)
- description : description (texte)
- fichier_path : chemin du fichier upload√© (texte, optionnel)
- lien_github : lien GitHub (texte, optionnel)
- note_ego : note donn√©e par Ego (float, optionnel)
- commentaire_ego : feedback d'Ego (texte, optionnel)
- validee : si accept√©e ou non (bool√©en)
- created_at : date de cr√©ation (datetime)

**Comment √©crire ce fichier :**
1. Importer SQLAlchemy :
   - `Column, Integer, String, Float, DateTime, Boolean, Text, ForeignKey`
   - `declarative_base, relationship`
2. Cr√©er `Base = declarative_base()`
3. Cr√©er chaque classe qui h√©rite de `Base`
4. D√©finir `__tablename__` pour chaque table
5. Ajouter les colonnes avec leurs types
6. D√©finir les relations (User a plusieurs Missions, etc.)

**Comment savoir que √ßa marche :**
- Le fichier existe dans app/
- Tu peux l'importer : `from app.models import User, Mission`
- Aucune erreur de syntaxe

**Pourquoi ces tables :**
- **User** : stocke toutes les stats du joueur
- **Mission** : objectifs assign√©s par Ego
- **Conversation** : historique du chat pour contexte
- **Soumission** : r√©sultats envoy√©s par l'utilisateur

---

### ‚úÖ √âtape 2.3 : Cr√©er app/schemas.py (Validation des donn√©es)

**Ce que ce fichier doit faire :**
D√©finir les sch√©mas Pydantic pour valider les donn√©es re√ßues et envoy√©es par l'API.

**Sch√©mas √† cr√©er :**

**Pour User :**
- `UserCreate` : pour cr√©er un utilisateur (username)
- `UserResponse` : pour retourner un utilisateur (tous les champs sauf sensibles)
- `UserStats` : pour les statistiques (niveau, points, projets, etc.)

**Pour Mission :**
- `MissionCreate` : cr√©er une mission (titre, description, points, deadline)
- `MissionUpdate` : mettre √† jour une mission (statut, completed_at)
- `MissionResponse` : retourner une mission compl√®te

**Pour Conversation :**
- `MessageRequest` : message envoy√© par l'user (message_user)
- `MessageResponse` : r√©ponse avec message Ego

**Pour Soumission :**
- `SoumissionCreate` : cr√©er une soumission (titre, description, fichier, lien)
- `SoumissionResponse` : retourner avec √©valuation d'Ego

**Comment √©crire ce fichier :**
1. Importer `BaseModel, Field, validator` de `pydantic`
2. Importer `datetime, Optional`
3. Cr√©er chaque classe h√©ritant de `BaseModel`
4. D√©finir les champs avec leurs types
5. Ajouter `Config` avec `from_attributes = True` pour compatibilit√© ORM
6. Ajouter des validateurs si n√©cessaire (ex: username > 3 caract√®res)

**Exemple de structure :**
```
class UserCreate(BaseModel):
    username: str = Field(min_length=3, max_length=50)

class UserResponse(BaseModel):
    id: int
    username: str
    niveau: int
    total_points: int
    projets_termines: int
    streak_actuel: int
    created_at: datetime

    class Config:
        from_attributes = True
```

**Comment savoir que √ßa marche :**
- Le fichier existe dans app/
- Tu peux l'importer : `from app.schemas import UserCreate`
- Pydantic valide automatiquement les donn√©es

---

### ‚úÖ √âtape 2.4 : Cr√©er app/database.py

**Ce que ce fichier doit faire :**
G√©rer la connexion √† la base de donn√©es SQLite.

**Fonctions √† cr√©er :**

**1. Configuration du moteur :**
- Cr√©er le moteur async SQLAlchemy avec l'URL depuis config
- Activer le mode `echo` si DEBUG=True (pour voir les requ√™tes SQL)

**2. SessionMaker :**
- Cr√©er un `async_session_maker` pour obtenir des sessions
- Configuration : `expire_on_commit=False`

**3. Fonction `get_db()` :**
- Dependency FastAPI qui fournit une session de DB
- Utilise `yield` pour donner la session
- Ferme automatiquement la session apr√®s usage

**4. Fonction `init_db()` :**
- Cr√©e toutes les tables d√©finies dans models.py
- √Ä appeler au d√©marrage de l'application
- Affiche un message de confirmation

**Comment √©crire ce fichier :**
1. Importer `create_async_engine, AsyncSession` de SQLAlchemy
2. Importer `sessionmaker`
3. Importer `get_settings` et `Base` des mod√®les
4. Cr√©er le moteur avec `create_async_engine(settings.database_url)`
5. Cr√©er le sessionmaker
6. D√©finir `get_db()` comme fonction async generator
7. D√©finir `init_db()` qui cr√©e les tables

**Comment savoir que √ßa marche :**
- Le fichier existe dans app/
- Tu peux l'importer sans erreur
- La fonction `init_db()` cr√©e le fichier .db

**Test rapide :**
Cr√©er un fichier test `test_db.py` :
```python
import asyncio
from app.database import init_db

asyncio.run(init_db())
```

Lancer : `python test_db.py`
- Tu dois voir : "‚úÖ Base de donn√©es initialis√©e !"
- Un fichier `ego_bluelock.db` appara√Æt √† la racine

---

### ‚úÖ √âtape 2.5 : Tester la cr√©ation de la base de donn√©es

**Ce que tu dois faire :**
V√©rifier que la base de donn√©es se cr√©e correctement.

**Test manuel :**
1. Cr√©er un fichier `init_database.py` √† la racine
2. Contenu :
```python
import asyncio
from app.database import init_db

async def main():
    print("üîÑ Initialisation de la base de donn√©es...")
    await init_db()
    print("‚úÖ Termin√© ! Fichier .db cr√©√©.")

if __name__ == "__main__":
    asyncio.run(main())
```
3. Lancer : `python init_database.py`

**Comment savoir que √ßa marche :**
- Tu vois les messages de confirmation
- Un fichier `ego_bluelock.db` appara√Æt √† la racine du projet
- Aucune erreur

**Inspection de la base (optionnel) :**
- Installer DB Browser for SQLite (logiciel gratuit)
- Ouvrir le fichier .db
- Tu dois voir 4 tables : users, missions, conversations, soumissions
- Chaque table a les colonnes d√©finies dans models.py

**Probl√®mes courants :**
- **"Table already exists"** : normal si tu relances, les tables existent d√©j√†
- **Erreur de connexion** : v√©rifie DATABASE_URL dans .env
- **Import error** : v√©rifie que tous les fichiers sont bien cr√©√©s

---

## JOUR 3 : SERVICE IA AVEC GROQ (5-6 heures)

### üéØ Objectif du jour
Cr√©er le service qui communique avec l'API Groq et g√®re la personnalit√© d'Ego.

---

### ‚úÖ √âtape 3.1 : Comprendre l'API Groq

**Ce que tu dois savoir :**

**Mod√®les disponibles :**
- `llama-3.1-70b-versatile` : le plus intelligent (recommand√©)
- `llama-3.1-8b-instant` : plus rapide, moins intelligent
- `mixtral-8x7b-32768` : bon compromis
- `gemma2-9b-it` : l√©ger et rapide

**Structure d'un appel API :**
```
Client Groq ‚Üí Envoie un prompt avec:
   - messages (liste de dicts avec role et content)
   - model (le mod√®le √† utiliser)
   - temperature (cr√©ativit√©, 0-1)
   - max_tokens (longueur max r√©ponse)

API Groq ‚Üí Retourne:
   - choices[0].message.content (la r√©ponse)
```

**Les roles dans les messages :**
- `system` : instructions pour l'IA (c'est Ego, parle comme...)
- `user` : message de l'utilisateur
- `assistant` : r√©ponse de l'IA (pour historique)

**Exemple conceptuel :**
```
messages = [
    {"role": "system", "content": "Tu es Ego Jinpachi..."},
    {"role": "user", "content": "Comment progresser ?"},
]
```

---

### ‚úÖ √âtape 3.2 : Cr√©er app/services/ai_service.py

**Ce que ce fichier doit faire :**
G√©rer toutes les interactions avec Groq API et la personnalit√© d'Ego.

**Fonctions √† cr√©er :**

**1. Fonction `construire_prompt_systeme(user_stats: dict) -> str` :**

**Ce qu'elle doit faire :**
- Prendre en param√®tre les stats de l'utilisateur
- Construire le prompt syst√®me qui d√©finit Ego
- Injecter les stats dans le prompt
- Retourner le prompt complet

**Contenu du prompt :**
```
Tu es Ego Jinpachi, le coach impitoyable de Blue Lock.
Tu entra√Ænes {username} √† devenir un d√©veloppeur d'√©lite.

R√àGLES ABSOLUES :
- Parle comme Ego : direct, provocateur, mais juste
- Utilise "Tch", "Hmph", "Path√©tique" souvent
- Compare toujours avec d'autres joueurs fictifs (Bachira, Isagi, Nagi)
- Cr√©e une comp√©tition constante
- Reconna√Æt les progr√®s MAIS garde la pression
- Vocabulaire Blue Lock : "√©go√Øste", "m√©diocre", "arme", "survie", "√©limination"
- Jamais trop encourageant, toujours challenge

STATS ACTUELLES DE {username} :
- Niveau : {niveau}
- Points totaux : {total_points}
- Projets termin√©s : {projets_termines}
- Streak actuel : {streak_actuel} jours
- Meilleur streak : {meilleur_streak} jours
- Comp√©tences : {competences}

COMPORTEMENT SELON NIVEAU :
- Niveau 0-2 : Tr√®s dur, presque m√©prisant, "t'es m√™me pas digne de Blue Lock"
- Niveau 3-5 : Reconna√Æt progr√®s mais pousse plus fort
- Niveau 6-8 : Respect gagn√©, d√©fis plus ambitieux
- Niveau 9+ : Elite, mais doit maintenir son rang

R√âACTIONS SELON CONTEXTE :
- Si streak cass√© : D√©√ßu mais remotivant, "c'est √ßa qui s√©pare les √©go√Østes des m√©diocres"
- Si nouvel accomplissement : F√©licite √† sa mani√®re, "Hmph, pas mal"
- Si √©chec/blocage : Provoque pour d√©bloquer, "tu vas abandonner comme √ßa ?"
- Si demande d'aide : Donne des pistes mais force √† chercher

R√©ponds TOUJOURS en fran√ßais avec ton style unique.
Sois concis (max 150 mots par r√©ponse).
```

**Comment l'√©crire :**
- Utiliser des f-strings Python pour injecter les variables
- Formater proprement (indentation)
- Tester avec diff√©rentes stats

**2. Fonction `obtenir_reponse_ego(message: str, user_stats: dict, historique: list = None) -> dict` :**

**Ce qu'elle doit faire :**
- Prendre le message de l'utilisateur
- Prendre les stats actuelles
- Prendre l'historique des messages (optionnel)
- Construire le prompt syst√®me
- Appeler l'API Groq
- Retourner la r√©ponse d'Ego

**√âtapes :**
1. Importer et initialiser le client Groq avec la cl√© API
2. Construire le prompt syst√®me avec `construire_prompt_systeme()`
3. Construire la liste des messages :
   - Ajouter le message system
   - Ajouter l'historique si pr√©sent (limit√© aux 10 derniers)
   - Ajouter le message actuel de l'user
4. Appeler `client.chat.completions.create()` avec :
   - model : depuis config
   - messages : la liste construite
   - temperature : depuis config (0.3 pour coh√©rence)
   - max_tokens : depuis config
5. Extraire la r√©ponse
6. Retourner un dict avec :
   - `reponse` : le texte de la r√©ponse
   - `tokens_used` : nombre de tokens utilis√©s
   - `model_used` : mod√®le utilis√©

**Gestion d'erreurs :**
- Wrappe dans try/except
- Si erreur API : retourne une r√©ponse par d√©faut d'Ego du genre "Tch, probl√®me technique. Reviens plus tard."
- Log l'erreur pour debug

**3. Fonction `analyser_soumission(titre: str, description: str, user_stats: dict) -> dict` :**

**Ce qu'elle doit faire :**
- Analyser une soumission de l'utilisateur (projet, code, etc.)
- Donner une note sur 10
- Donner un feedback d√©taill√© style Ego
- Sugg√©rer des am√©liorations

**Prompt sp√©cifique pour cette fonction :**
```
Tu es Ego Jinpachi et tu √©values la soumission d'un d√©veloppeur.

SOUMISSION :
Titre : {titre}
Description : {description}

STATS DU D√âVELOPPEUR :
{stats de l'user}

T√ÇCHE :
1. Analyse la soumission
2. Donne une note sur 10 (sois exigeant mais juste)
3. Cat√©gorise : ELITE (9-10), BON (7-8), MOYEN (5-6), FAIBLE (1-4)
4. Donne un feedback dans ton style (max 100 mots)
5. Sugg√®re 2-3 am√©liorations concr√®tes

RETOURNE UN JSON :
{
  "note": 7.5,
  "categorie": "BON",
  "feedback": "Hmph, pas mal pour ton niveau...",
  "ameliorations": ["...", "...", "..."],
  "points_gagnes": 50
}
```

**√âtapes :**
1. Construire ce prompt avec les donn√©es
2. Appeler Groq API
3. Parser la r√©ponse JSON
4. Valider les champs
5. Retourner le dict

**4. Fonction `generer_mission(user_stats: dict, difficulte: str = "normale") -> dict` :**

**Ce qu'elle doit faire :**
- G√©n√©rer une mission adapt√©e au niveau de l'utilisateur
- Difficult√© : facile, normale, difficile
- Mission coh√©rente avec ses comp√©tences actuelles

**Prompt :**
```
Tu es Ego Jinpachi. Cr√©e une mission de d√©veloppement pour {username}.

STATS :
- Niveau : {niveau}
- Comp√©tences : {competences}
- Projets termin√©s : {projets_termines}

DIFFICULT√â DEMAND√âE : {difficulte}

CONTRAINTES :
- Mission r√©alisable en 1-7 jours selon difficult√©
- Adapt√©e au niveau actuel
- Challenge mais pas impossible
- Technologie que l'user conna√Æt ou peut apprendre

RETOURNE UN JSON :
{
  "titre": "...",
  "description": "... (style Ego, 50 mots max)",
  "objectifs": ["...", "...", "..."],
  "duree_estimee": "3 jours",
  "points_recompense": 100,
  "competences_requises": ["...", "..."]
}
```

**√âtapes similaires :**
- Construire prompt
- Appeler API
- Parser JSON
- Valider
- Retourner

**Comment √©crire ce fichier :**

**Imports n√©cessaires :**
```python
from groq import Groq
from app.config import get_settings
import json
import logging
from typing import Optional, List, Dict
```

**Structure du fichier :**
```python
settings = get_settings()
client = Groq(api_key=settings.groq_api_key)
logger = logging.getLogger(__name__)

# Fonction 1: construire_prompt_systeme()
# Fonction 2: obtenir_reponse_ego()
# Fonction 3: analyser_soumission()
# Fonction 4: generer_mission()
```

**Comment savoir que √ßa marche :**
- Le fichier existe dans app/services/
- Tu peux l'importer sans erreur
- Chaque fonction a une docstring expliquant son r√¥le

---

### ‚úÖ √âtape 3.3 : Tester le service IA manuellement

**Ce que tu dois faire :**
Cr√©er un script de test pour v√©rifier que l'IA r√©pond correctement.

**Cr√©er `test_ai.py` √† la racine :**

**Contenu du fichier :**
```python
import asyncio
from app.services.ai_service import (
    obtenir_reponse_ego,
    analyser_soumission,
    generer_mission
)

async def test_reponse_simple():
    """Test 1: Conversation simple"""
    print("\nüß™ TEST 1: Conversation simple")
    print("-" * 50)

    user_stats = {
        "username": "TestUser",
        "niveau": 3,
        "total_points": 150,
        "projets_termines": 5,
        "streak_actuel": 2,
        "meilleur_streak": 7,
        "competences": ["Python", "FastAPI"]
    }

    message = "Comment progresser en Python ?"

    resultat = obtenir_reponse_ego(message, user_stats)

    print(f"üì© Message: {message}")
    print(f"ü§ñ R√©ponse Ego: {resultat['reponse']}")
    print(f"üìä Tokens utilis√©s: {resultat['tokens_used']}")

async def test_analyse_soumission():
    """Test 2: Analyse de soumission"""
    print("\nüß™ TEST 2: Analyse de soumission")
    print("-" * 50)

    user_stats = {
        "username": "TestUser",
        "niveau": 4,
        "total_points": 200,
        "projets_termines": 8,
        "streak_actuel": 5,
        "meilleur_streak": 10,
        "competences": ["Python", "FastAPI", "SQLite"]
    }

    titre = "API REST pour gestion de t√¢ches"
    description = """
    J'ai cr√©√© une API REST avec FastAPI qui permet de :
    - Cr√©er des t√¢ches
    - Les lister
    - Les marquer comme compl√©t√©es
    - Base de donn√©es SQLite
    - Documentation Swagger auto-g√©n√©r√©e
    """

    resultat = analyser_soumission(titre, description, user_stats)

    print(f"üìù Soumission: {titre}")
    print(f"‚≠ê Note: {resultat['note']}/10")
    print(f"üè∑Ô∏è Cat√©gorie: {resultat['categorie']}")
    print(f"üí¨ Feedback: {resultat['feedback']}")
    print(f"üìà Am√©liorations:")
    for i, amelioration in enumerate(resultat['ameliorations'], 1):
        print(f"   {i}. {amelioration}")
    print(f"üéÅ Points gagn√©s: {resultat['points_gagnes']}")

async def test_generation_mission():
    """Test 3: G√©n√©ration de mission"""
    print("\nüß™ TEST 3: G√©n√©ration de mission")
    print("-" * 50)

    user_stats = {
        "username": "TestUser",
        "niveau": 5,
        "total_points": 350,
        "projets_termines": 12,
        "streak_actuel": 8,
        "meilleur_streak": 15,
        "competences": ["Python", "FastAPI", "SQLite", "HTML/CSS"]
    }

    resultat = generer_mission(user_stats, difficulte="normale")

    print(f"üéØ Mission: {resultat['titre']}")
    print(f"üìã Description: {resultat['description']}")
    print(f"‚úÖ Objectifs:")
    for i, obj in enumerate(resultat['objectifs'], 1):
        print(f"   {i}. {obj}")
    print(f"‚è±Ô∏è Dur√©e estim√©e: {resultat['duree_estimee']}")
    print(f"üéÅ Points r√©compense: {resultat['points_recompense']}")
    print(f"üõ†Ô∏è Comp√©tences requises: {', '.join(resultat['competences_requises'])}")

async def main():
    """Lancer tous les tests"""
    print("=" * 50)
    print("üöÄ TESTS DU SERVICE IA")
    print("=" * 50)

    try:
        await test_reponse_simple()
        await test_analyse_soumission()
        await test_generation_mission()

        print("\n" + "=" * 50)
        print("‚úÖ TOUS LES TESTS ONT R√âUSSI !")
        print("=" * 50)

    except Exception as e:
        print(f"\n‚ùå ERREUR: {e}")
        import traceback
        traceback.print_exc()

if __name__ == "__main__":
    asyncio.run(main())
```

**Comment lancer les tests :**
```bash
python test_ai.py
```

**Ce que tu dois voir :**
- Chaque test s'ex√©cute s√©quentiellement
- Tu vois les r√©ponses d'Ego en fran√ßais
- Le style est bien celui de Blue Lock (provocateur, comparaisons)
- Les notes et missions sont coh√©rentes
- Aucune erreur

**Comment savoir que √ßa marche :**
- ‚úÖ Test 1 : Ego r√©pond en fran√ßais avec sa personnalit√©
- ‚úÖ Test 2 : La soumission est analys√©e avec note et feedback
- ‚úÖ Test 3 : Une mission est g√©n√©r√©e adapt√©e au niveau
- ‚úÖ Aucune erreur API
- ‚úÖ Les tokens sont compt√©s

**Probl√®mes courants :**
- **"Invalid API key"** : v√©rifie GROQ_API_KEY dans .env
- **Timeout** : connexion internet lente, augmente le timeout
- **R√©ponse en anglais** : ajoute "R√©ponds UNIQUEMENT en fran√ßais" dans le prompt
- **Erreur JSON** : l'IA n'a pas retourn√© un JSON valide, am√©liore le prompt

**Am√©liorations √† tester :**
- Change les stats (niveau 0 vs niveau 10) et vois la diff√©rence de ton
- Teste avec diff√©rents types de soumissions
- Teste avec diff√©rentes difficult√©s de mission

---

### ‚úÖ √âtape 3.4 : Optimiser les prompts

**Ce que tu dois faire :**
Affiner les prompts pour avoir des r√©ponses plus coh√©rentes.

**Techniques d'optimisation :**

**1. Ajouter des exemples (Few-shot learning) :**

Dans le prompt syst√®me, ajouter :
```
EXEMPLES DE R√âPONSES :

User: "J'ai r√©ussi mon premier projet"
Ego: "Hmph, UN projet ? Bachira en fait trois par semaine.
Mais pour un d√©butant niveau 2, c'est pas totalement path√©tique.
Continue comme √ßa et tu survivras peut-√™tre dans Blue Lock."

User: "Je suis bloqu√© sur ce bug"
Ego: "Bloqu√© ? Les vrais √©go√Østes D√âVORENT les bugs.
Isagi a debugg√© pendant 12h d'affil√©e sur son dernier projet.
Montre-moi ce bug. On va l'√©craser ensemble."
```

**2. Contraintes strictes :**

Ajouter dans chaque prompt :
```
CONTRAINTES STRICTES :
- Longueur max : 150 mots
- Toujours finir par une action ou question
- Toujours r√©f√©rencer au moins une stat de l'user
- Jamais dire "je ne peux pas" ou "d√©sol√©"
- Vocabulaire Blue Lock obligatoire
```

**3. Format de sortie clair :**

Pour les fonctions qui retournent du JSON, ajouter :
```
IMPORTANT : Retourne UNIQUEMENT le JSON, aucun texte avant ou apr√®s.
Format EXACT :
{
  "champ1": "valeur",
  "champ2": 123
}
```

**4. Tester les edge cases :**

Cr√©er des tests avec :
- Niveau 0 (d√©butant total)
- Niveau 10 (expert)
- Streak cass√© (0 jours)
- Tr√®s long streak (100+ jours)
- Soumission excellente vs m√©diocre

**Comment savoir que √ßa marche :**
- Les r√©ponses sont coh√©rentes avec le niveau
- Le ton varie selon les stats
- Pas de hors-sujet
- JSON toujours valide
- Style Blue Lock constant

---

## JOUR 4 : SERVICES DE GESTION (4-5 heures)

### üéØ Objectif du jour
Cr√©er les services qui g√®rent les stats, missions et notifications.

---

### ‚úÖ √âtape 4.1 : Cr√©er app/services/stats_service.py

**Ce que ce fichier doit faire :**
G√©rer toutes les op√©rations sur les statistiques de l'utilisateur.

**Fonctions √† cr√©er :**

**1. Fonction `calculer_niveau(total_points: int) -> int` :**

**Ce qu'elle fait :**
- Prend les points totaux
- Calcule le niveau selon une formule
- Retourne le niveau

**Formule recommand√©e :**
```
Niveau = floor(sqrt(total_points / 100))

Exemples :
- 0-99 points = Niveau 0
- 100-399 points = Niveau 1
- 400-899 points = Niveau 2
- 900-1599 points = Niveau 3
- etc.
```

**Pourquoi cette formule :**
- Progression exponentielle (de plus en plus dur)
- √âquilibr√© pour un jeu long terme

**2. Fonction `calculer_points_mission(difficulte: str, temps_pris: int, qualite: float) -> int` :**

**Ce qu'elle fait :**
- Calcule les points gagn√©s pour une mission
- Prend en compte : difficult√©, temps, qualit√©

**Formule :**
```
Base selon difficult√© :
- facile : 50 points
- normale : 100 points
- difficile : 200 points

Bonus temps (si fini avant deadline) :
- +20% si termin√© avec 50%+ du temps restant
- +10% si termin√© avec 25-50% du temps restant
- +0% si termin√© dans les derniers 25%

Bonus qualit√© (note de l'IA) :
- Note 9-10 : +30%
- Note 7-8 : +15%
- Note 5-6 : +0%
- Note <5 : -20%

Total = Base * (1 + bonus_temps + bonus_qualite)
```

**3. Fonction `mettre_a_jour_streak(user, db_session) -> dict` :**

**Ce qu'elle fait :**
- V√©rifie la derni√®re activit√© de l'user
- Met √† jour le streak selon les r√®gles :
  - Si activit√© aujourd'hui : streak continue
  - Si activit√© hier : streak +1
  - Si activit√© il y a 2+ jours : streak reset √† 1
- Met √† jour meilleur_streak si battu
- Sauvegarde en DB
- Retourne les changements

**Logique :**
```
Calculer jours depuis derni√®re activit√©
Si 0 jours (d√©j√† actif aujourd'hui) :
    - Rien √† faire, streak continue
Si 1 jour (actif hier) :
    - streak_actuel += 1
    - Si streak_actuel > meilleur_streak :
        meilleur_streak = streak_actuel
Si 2+ jours :
    - streak_actuel = 1 (reset mais compte aujourd'hui)

Mettre derniere_activite = maintenant
Sauvegarder
```

**4. Fonction `ajouter_competence(user, competence: str, db_session) -> bool` :**

**Ce qu'elle fait :**
- Ajoute une comp√©tence √† la liste de l'user
- V√©rifie qu'elle n'existe pas d√©j√†
- Met √† jour en DB
- Retourne True si ajout√©e, False si d√©j√† pr√©sente

**Logique :**
```
Charger liste actuelle (JSON string ‚Üí list)
Si competence pas dans liste :
    Ajouter √† la liste
    Convertir en JSON string
    Sauvegarder en DB
    Return True
Sinon :
    Return False
```

**5. Fonction `obtenir_classement_fictif(user_niveau: int) -> list` :**

**Ce qu'elle fait :**
- G√©n√®re un classement fictif pour la gamification
- Positionne l'user parmi des personnages Blue Lock
- Retourne une liste de 10 joueurs avec l'user dedans

**Liste des personnages Blue Lock (r√©f√©rence) :**
```
- Isagi Yoichi (strat√®ge)
- Bachira Meguru (cr√©atif)
- Nagi Seishiro (g√©nie paresseux)
- Chigiri Hyoma (vitesse)
- Kunigami Rensuke (puissant)
- Barou Shoei (roi)
- Rin Itoshi (prodige)
- Shidou Ryusei (chaotique)
- Reo Mikage (riche)
- Yukimiya Kenyu (√©l√©gant)
```

**Logique du classement :**
```
Cr√©er 10 personnages avec niveaux fictifs autour de l'user
Placer l'user selon son niveau :
- Niveau 0-2 : dernier du classement
- Niveau 3-5 : milieu de classement
- Niveau 6-8 : top 5
- Niveau 9+ : top 3

Ajouter variations al√©atoires pour r√©alisme
Retourner liste tri√©e par niveau d√©croissant
```

**Comment √©crire ce fichier :**

**Imports :**
```python
from sqlalchemy.ext.asyncio import AsyncSession
from app.models import User
from datetime import datetime, timedelta
import json
import math
import random
from typing import Dict, List
```

**Structure :**
```python
# Fonction 1: calculer_niveau()
# Fonction 2: calculer_points_mission()
# Fonction 3: mettre_a_jour_streak()
# Fonction 4: ajouter_competence()
# Fonction 5: obtenir_classement_fictif()
```

**Comment savoir que √ßa marche :**
- Le fichier existe dans app/services/
- Chaque fonction a une docstring
- Tu peux importer sans erreur

---

### ‚úÖ √âtape 4.2 : Cr√©er app/services/mission_service.py

**Ce que ce fichier doit faire :**
G√©rer la cr√©ation, mise √† jour et compl√©tion des missions.

**Fonctions √† cr√©er :**

**1. Fonction `creer_mission(user_id: int, mission_data: dict, db_session) -> Mission` :**

**Ce qu'elle fait :**
- Cr√©e une nouvelle mission en DB
- Calcule la deadline selon la dur√©e estim√©e
- Retourne l'objet Mission cr√©√©

**Param√®tres :**
```python
mission_data = {
    "titre": "...",
    "description": "...",
    "points_recompense": 100,
    "duree_estimee_jours": 3
}
```

**Logique :**
```
Cr√©er objet Mission
Remplir les champs
Calculer deadline = maintenant + duree_estimee_jours
Statut = "active"
Ajouter √† la session DB
Commit
Retourner mission
```

**2. Fonction `obtenir_missions_actives(user_id: int, db_session) -> List[Mission]` :**

**Ce qu'elle fait :**
- R√©cup√®re toutes les missions actives d'un user
- Trie par deadline (plus proches en premier)
- Retourne la liste

**3. Fonction `verifier_deadlines(user_id: int, db_session) -> Dict` :**

**Ce qu'elle fait :**
- V√©rifie toutes les missions actives
- Identifie celles dont la deadline est d√©pass√©e
- Les marque comme "failed"
- Retourne les stats (nombre √©checs, points perdus)

**Logique :**
```
R√©cup√©rer missions actives
Pour chaque mission :
    Si deadline < maintenant :
        Changer statut en "failed"
        Compter dans √©checs
    Sinon si deadline - maintenant < 24h :
        Ajouter dans "urgentes"

Sauvegarder changements
Retourner {
    "missions_echouees": count,
    "missions_urgentes": list
}
```

**4. Fonction `completer_mission(mission_id: int, note: float, db_session) -> Dict` :**

**Ce qu'elle fait :**
- Marque une mission comme compl√©t√©e
- Calcule les points gagn√©s selon note et timing
- Met √† jour les stats de l'user
- Retourne le r√©sum√©

**Logique :**
```
R√©cup√©rer la mission
V√©rifier qu'elle est "active"

Calculer temps pris = maintenant - created_at
Calculer points avec stats_service.calculer_points_mission()

Mettre √† jour mission :
    statut = "completed"
    completed_at = maintenant

Mettre √† jour user :
    total_points += points
    projets_termines += 1
    niveau = calculer_niveau(total_points)

Sauvegarder

Retourner {
    "mission_id": ...,
    "points_gagnes": ...,
    "nouveau_niveau": ...,
    "niveau_monte": True/False
}
```

**Comment √©crire ce fichier :**

**Imports :**
```python
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select
from app.models import Mission, User
from app.services.stats_service import calculer_niveau, calculer_points_mission
from datetime import datetime, timedelta
from typing import List, Dict, Optional
```

**Comment savoir que √ßa marche :**
- Le fichier existe dans app/services/
- Tu peux l'importer sans erreur

---

### ‚úÖ √âtape 4.3 : Cr√©er app/services/notification_service.py

**Ce que ce fichier doit faire :**
G√©rer les rappels et notifications automatiques.

**Fonctions √† cr√©er :**

**1. Fonction `programmer_rappel(user_id: int, mission_id: int, moment: str)` :**

**Ce qu'elle fait :**
- Programme un rappel pour une mission
- Moments possibles : "debut_journee", "milieu_journee", "fin_journee", "deadline_proche"
- Utilise APScheduler pour les t√¢ches programm√©es

**Logique :**
```
Selon le moment :
    "debut_journee" : 9h00
    "milieu_journee" : 13h00
    "fin_journee" : 18h00
    "deadline_proche" : 24h avant deadline

Cr√©er job APScheduler
Stocker r√©f√©rence du job
```

**2. Fonction `envoyer_rappel(user_id: int, mission_id: int, type: str)` :**

**Ce qu'elle fait :**
- G√©n√®re un message de rappel style Ego
- Selon le type de rappel
- Sauvegarde dans un syst√®me de notifications

**Types de messages :**
```
"debut_journee" :
    "Debout √©go√Øste ! Ta mission '{titre}' t'attend.
    Deadline dans {X} jours. Bachira a d√©j√† commenc√© √† 6h."

"milieu_journee" :
    "O√π t'en es sur '{titre}' ? La journ√©e avance et
    je vois toujours rien. Les m√©diocres procrastinent."

"fin_journee" :
    "Bilan de la journ√©e sur '{titre}' ? T'as int√©r√™t
    √† avoir avanc√© ou demain √ßa va chauffer."

"deadline_proche" :
    "ATTENTION ! Plus que 24h pour '{titre}' !
    C'est maintenant que les vrais √©go√Østes se r√©v√®lent !"
```

**3. Fonction `initialiser_scheduler() -> BackgroundScheduler` :**

**Ce qu'elle fait :**
- Cr√©e et configure APScheduler
- D√©marre le scheduler
- Retourne l'instance

**Configuration :**
```python
from apscheduler.schedulers.asyncio import AsyncIOScheduler

scheduler = AsyncIOScheduler()
scheduler.start()
return scheduler
```

**4. Fonction `verifier_missions_quotidien(db_session)` :**

**Ce qu'elle fait :**
- T√¢che qui tourne tous les jours √† 9h
- V√©rifie toutes les missions de tous les users
- Envoie rappels pour missions urgentes
- Marque missions expir√©es comme "failed"

**Comment √©crire ce fichier :**

**Imports :**
```python
from apscheduler.schedulers.asyncio import AsyncIOScheduler
from apscheduler.triggers.cron import CronTrigger
from sqlalchemy.ext.asyncio import AsyncSession
from app.models import User, Mission
from datetime import datetime, timedelta
from typing import Dict
import logging
```

**Comment savoir que √ßa marche :**
- Le fichier existe
- Tu peux l'importer
- Le scheduler se lance sans erreur

---

### ‚úÖ √âtape 4.4 : Tester les services

**Ce que tu dois faire :**
Cr√©er un fichier de test pour v√©rifier tous les services.

**Cr√©er `test_services.py` √† la racine :**

**Tests √† inclure :**

**Test 1: Stats Service**
```python
# Tester calcul niveau
assert calculer_niveau(0) == 0
assert calculer_niveau(100) == 1
assert calculer_niveau(400) == 2

# Tester calcul points
points = calculer_points_mission("normale", 2, 8.5)
assert 100 <= points <= 180  # Avec bonus

# Tester classement
classement = obtenir_classement_fictif(5)
assert len(classement) == 10
assert any(j["nom"] == "Toi" for j in classement)
```

**Test 2: Mission Service**
```python
# Cr√©er une mission test
mission_data = {
    "titre": "Test Mission",
    "description": "Description test",
    "points_recompense": 100,
    "duree_estimee_jours": 3
}
# V√©rifier cr√©ation
# V√©rifier deadline
# V√©rifier r√©cup√©ration
```

**Test 3: Notification Service**
```python
# Tester g√©n√©ration message rappel
message = envoyer_rappel(1, 1, "debut_journee")
assert "√©go√Øste" in message.lower()
assert len(message) > 0

# Tester scheduler
scheduler = initialiser_scheduler()
assert scheduler.running
```

**Lancer les tests :**
```bash
python test_services.py
```

**Comment savoir que √ßa marche :**
- Tous les tests passent (vert)
- Aucune assertion √©choue
- Les calculs sont corrects
- Messages g√©n√©r√©s sont coh√©rents

---

## JOUR 5 : API ROUTES (5-6 heures)

### üéØ Objectif du jour
Cr√©er toutes les routes de l'API REST avec FastAPI.

---

### ‚úÖ √âtape 5.1 : Cr√©er app/api/dependencies.py

**Ce que ce fichier doit faire :**
D√©finir les d√©pendances r√©utilisables pour les routes.

**D√©pendances √† cr√©er :**

**1. `get_current_user(username: str, db: AsyncSession)` :**

**Ce qu'elle fait :**
- R√©cup√®re l'utilisateur depuis la DB par username
- Si n'existe pas, le cr√©e automatiquement
- Retourne l'objet User

**Logique :**
```
Chercher user par username dans DB
Si trouv√© :
    Retourner user
Sinon :
    Cr√©er nouveau user avec valeurs par d√©faut
    Sauvegarder en DB
    Retourner user cr√©√©
```

**Pourquoi cr√©er auto :**
- Simplifie l'utilisation (pas besoin d'inscription s√©par√©e)
- Pour un POC, c'est suffisant
- Plus tard, on peut ajouter authentification r√©elle

**2. `verifier_session_active(user_id: int, db: AsyncSession)` :**

**Ce qu'elle fait :**
- V√©rifie qu'un user est actif
- Met √† jour son streak
- Retourne les infos de session

**Logique :**
```
R√©cup√©rer user
Appeler stats_service.mettre_a_jour_streak()
Retourner {
    "user_id": ...,
    "streak_mise_a_jour": True/False,
    "nouveau_streak": ...
}
```

**Comment √©crire ce fichier :**

**Imports :**
```python
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select
from app.models import User
from app.database import get_db
from app.services.stats_service import mettre_a_jour_streak
from fastapi import Depends, HTTPException
from typing import Optional
```

**Structure :**
```python
async def get_current_user(
    username: str,
    db: AsyncSession = Depends(get_db)
) -> User:
    # Logique ici

async def verifier_session_active(
    user_id: int,
    db: AsyncSession = Depends(get_db)
) -> dict:
    # Logique ici
```

**Comment savoir que √ßa marche :**
- Le fichier existe dans app/api/
- Tu peux l'importer
- Les fonctions ont les bons types de retour

---

### ‚úÖ √âtape 5.2 : Cr√©er app/api/routes.py

**Ce que ce fichier doit faire :**
D√©finir toutes les routes de l'API.

**Routes √† cr√©er :**

### **ROUTES UTILISATEUR**

**1. POST /api/users/init**

**Ce qu'elle fait :**
- Initialise ou r√©cup√®re un utilisateur
- Param√®tres : username (dans le body)
- Retourne : infos compl√®tes de l'user

**Request body :**
```json
{
  "username": "MonPseudo"
}
```

**Response :**
```json
{
  "id": 1,
  "username": "MonPseudo",
  "niveau": 0,
  "total_points": 0,
  "projets_termines": 0,
  "streak_actuel": 0,
  "meilleur_streak": 0,
  "competences": [],
  "created_at": "2024-01-15T10:00:00"
}
```

**Code structure :**
```python
@router.post("/users/init", response_model=schemas.UserResponse)
async def initialiser_user(
    user_data: schemas.UserCreate,
    db: AsyncSession = Depends(get_db)
):
    # Utiliser get_current_user dependency
    # Retourner user
```

**2. GET /api/users/{username}/stats**

**Ce qu'elle fait :**
- R√©cup√®re les stats compl√®tes d'un user
- Inclut le classement fictif

**Response :**
```json
{
  "user": { ... },
  "classement": [
    {"rang": 1, "nom": "Isagi", "niveau": 15, "points": 22500},
    {"rang": 2, "nom": "Bachira", "niveau": 14, "points": 19600},
    {"rang": 5, "nom": "Toi", "niveau": 5, "points": 2500},
    ...
  ],
  "prochaine_niveau": {
    "niveau_suivant": 6,
    "points_requis": 3600,
    "points_manquants": 1100
  }
}
```

**3. POST /api/users/{username}/competence**

**Ce qu'elle fait :**
- Ajoute une comp√©tence √† l'user
- Param√®tres : competence (dans body)
- Retourne : user mis √† jour

**Request body :**
```json
{
  "competence": "React"
}
```

---

### **ROUTES CONVERSATION / CHAT**

**4. POST /api/chat**

**Ce qu'elle fait :**
- Envoie un message √† Ego
- R√©cup√®re la r√©ponse de l'IA
- Sauvegarde la conversation en DB
- Retourne la r√©ponse

**Request body :**
```json
{
  "username": "MonPseudo",
  "message": "Comment progresser en Python ?"
}
```

**Response :**
```json
{
  "message_user": "Comment progresser en Python ?",
  "reponse_ego": "Tch... Python ? C'est le langage des m√©diocres qui...",
  "timestamp": "2024-01-15T10:05:00",
  "contexte": {
    "niveau": 5,
    "streak": 8,
    "derniere_mission": "API REST"
  }
}
```

**Logique :**
```python
@router.post("/chat", response_model=schemas.MessageResponse)
async def chat_avec_ego(
    message_data: schemas.MessageRequest,
    db: AsyncSession = Depends(get_db)
):
    # 1. R√©cup√©rer user
    user = await get_current_user(message_data.username, db)

    # 2. V√©rifier et MAJ streak
    await verifier_session_active(user.id, db)

    # 3. R√©cup√©rer historique (10 derniers messages)
    historique = await recuperer_historique(user.id, db, limit=10)

    # 4. Construire stats pour contexte
    user_stats = construire_stats_dict(user)

    # 5. Appeler IA service
    reponse = obtenir_reponse_ego(
        message_data.message,
        user_stats,
        historique
    )

    # 6. Sauvegarder conversation
    conversation = Conversation(
        user_id=user.id,
        message_user=message_data.message,
        reponse_ego=reponse['reponse'],
        contexte=json.dumps(user_stats)
    )
    db.add(conversation)
    await db.commit()

    # 7. Retourner r√©ponse
    return {
        "message_user": message_data.message,
        "reponse_ego": reponse['reponse'],
        "timestamp": conversation.timestamp,
        "contexte": user_stats
    }
```

**5. GET /api/chat/{username}/historique**

**Ce qu'elle fait :**
- R√©cup√®re l'historique des conversations
- Param√®tres : limit (optionnel, d√©faut 50)
- Retourne : liste des conversations

**Response :**
```json
{
  "conversations": [
    {
      "id": 1,
      "message_user": "...",
      "reponse_ego": "...",
      "timestamp": "..."
    },
    ...
  ],
  "total": 145
}
```

---

### **ROUTES MISSIONS**

**6. POST /api/missions/generer**

**Ce qu'elle fait :**
- G√©n√®re une nouvelle mission via l'IA
- Cr√©e la mission en DB
- Retourne la mission cr√©√©e

**Request body :**
```json
{
  "username": "MonPseudo",
  "difficulte": "normale"
}
```

**Response :**
```json
{
  "id": 1,
  "titre": "Cr√©er une API CRUD compl√®te",
  "description": "Tch, tu vas me cr√©er une vraie API REST...",
  "objectifs": [
    "4 endpoints CRUD fonctionnels",
    "Base de donn√©es relationnelle",
    "Documentation Swagger"
  ],
  "points_recompense": 150,
  "deadline": "2024-01-20T18:00:00",
  "statut": "active",
  "competences_requises": ["Python", "FastAPI", "SQLAlchemy"]
}
```

**Logique :**
```python
@router.post("/missions/generer")
async def generer_mission(
    data: schemas.MissionGenerateRequest,
    db: AsyncSession = Depends(get_db)
):
    # 1. R√©cup√©rer user
    user = await get_current_user(data.username, db)

    # 2. Construire stats
    user_stats = construire_stats_dict(user)

    # 3. Appeler IA pour g√©n√©rer mission
    mission_data = generer_mission(user_stats, data.difficulte)

    # 4. Cr√©er mission en DB
    mission = await mission_service.creer_mission(
        user.id,
        mission_data,
        db
    )

    # 5. Retourner mission
    return mission
```

**7. GET /api/missions/{username}/actives**

**Ce qu'elle fait :**
- Liste toutes les missions actives d'un user
- Tri√© par deadline

**Response :**
```json
{
  "missions": [
    {
      "id": 1,
      "titre": "...",
      "deadline": "2024-01-18T18:00:00",
      "temps_restant": "2 jours 5 heures",
      "progression": "0%"
    },
    ...
  ],
  "total_actives": 3
}
```

**8. POST /api/missions/{mission_id}/completer**

**Ce qu'elle fait :**
- Marque une mission comme termin√©e
- Lance l'analyse de la soumission par l'IA
- Calcule et attribue les points
- Retourne le r√©sum√©

**Request body :**
```json
{
  "description": "J'ai cr√©√© l'API avec 4 endpoints...",
  "lien_github": "https://github.com/user/projet",
  "fichier": "optionnel"
}
```

**Response :**
```json
{
  "mission_id": 1,
  "statut": "completed",
  "analyse": {
    "note": 8.5,
    "categorie": "BON",
    "feedback": "Hmph, pas mal. L'API fonctionne...",
    "ameliorations": ["Ajouter tests", "G√©rer erreurs", "Optimiser queries"]
  },
  "recompenses": {
    "points_base": 150,
    "bonus_qualite": 22,
    "bonus_temps": 15,
    "total_gagne": 187
  },
  "progression_user": {
    "ancien_niveau": 5,
    "nouveau_niveau": 6,
    "niveau_monte": true,
    "nouveau_total_points": 2687
  }
}
```

**Logique :**
```python
@router.post("/missions/{mission_id}/completer")
async def completer_mission(
    mission_id: int,
    data: schemas.SoumissionCreate,
    db: AsyncSession = Depends(get_db)
):
    # 1. R√©cup√©rer mission
    mission = await recuperer_mission(mission_id, db)

    # 2. V√©rifier qu'elle est active
    if mission.statut != "active":
        raise HTTPException(400, "Mission d√©j√† termin√©e")

    # 3. Analyser la soumission avec IA
    user = await get_user_by_id(mission.user_id, db)
    user_stats = construire_stats_dict(user)

    analyse = analyser_soumission(
        data.titre,
        data.description,
        user_stats
    )

    # 4. Cr√©er soumission en DB
    soumission = Soumission(
        user_id=mission.user_id,
        mission_id=mission_id,
        titre=mission.titre,
        description=data.description,
        lien_github=data.lien_github,
        note_ego=analyse['note'],
        commentaire_ego=analyse['feedback'],
        validee=analyse['note'] >= 5.0
    )
    db.add(soumission)

    # 5. Compl√©ter mission et calculer points
    resultat = await mission_service.completer_mission(
        mission_id,
        analyse['note'],
        db
    )

    # 6. Retourner tout
    return {
        "mission_id": mission_id,
        "statut": "completed",
        "analyse": analyse,
        "recompenses": resultat,
        "progression_user": {
            "ancien_niveau": user.niveau,
            "nouveau_niveau": resultat['nouveau_niveau'],
            "niveau_monte": resultat['niveau_monte'],
            "nouveau_total_points": user.total_points
        }
    }
```

**9. DELETE /api/missions/{mission_id}**

**Ce qu'elle fait :**
- Abandonne/supprime une mission
- P√©nalit√© de points possible

---

### **ROUTES UTILITAIRES**

**10. GET /api/health**

**Ce qu'elle fait :**
- V√©rifie que l'API fonctionne
- V√©rifie connexion DB
- V√©rifie API Groq

**Response :**
```json
{
  "status": "healthy",
  "database": "connected",
  "ai_service": "operational",
  "timestamp": "2024-01-15T10:00:00"
}
```

**11. GET /api/stats/global**

**Ce qu'elle fait :**
- Statistiques globales de l'application
- Nombre total d'users, missions, conversations

**Response :**
```json
{
  "total_users": 42,
  "total_missions": 186,
  "total_conversations": 1547,
  "missions_completees": 98,
  "taux_succes": 52.7
}
```

---

### ‚úÖ √âtape 5.3 : Assembler dans app/main.py

**Ce que ce fichier doit faire :**
- Cr√©er l'application FastAPI
- Inclure toutes les routes
- Configurer CORS
- Initialiser la DB au d√©marrage
- D√©marrer le scheduler de notifications

**Structure compl√®te :**

```python
from fastapi import FastAPI
from fastapi.middleware.cors import CORSMiddleware
from fastapi.staticfiles import StaticFiles
from app.api.routes import router
from app.database import init_db
from app.services.notification_service import initialiser_scheduler
from app.config import get_settings
import logging

settings = get_settings()

# Configuration logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

# Cr√©er app
app = FastAPI(
    title=settings.app_name,
    description="Application de coaching IA style Blue Lock",
    version="1.0.0"
)

# CORS (pour permettre frontend de communiquer)
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],  # En prod, sp√©cifier les domaines
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# Inclure les routes
app.include_router(router, prefix="/api")

# Servir les fichiers statiques du frontend
app.mount("/static", StaticFiles(directory="frontend"), name="static")

# Event au d√©marrage
@app.on_event("startup")
async def startup_event():
    logger.info("üöÄ D√©marrage de l'application...")

    # Initialiser DB
    await init_db()
    logger.info("‚úÖ Base de donn√©es initialis√©e")

    # D√©marrer scheduler
    scheduler = initialiser_scheduler()
    logger.info("‚úÖ Scheduler de notifications d√©marr√©")

    logger.info("üéØ Application pr√™te !")

# Event √† l'arr√™t
@app.on_event("shutdown")
async def shutdown_event():
    logger.info("üëã Arr√™t de l'application...")

# Route racine
@app.get("/")
async def root():
    return {
        "message": "Bienvenue dans Ego IA Blue Lock",
        "docs": "/docs",
        "frontend": "/static/index.html"
    }
```

**Comment savoir que √ßa marche :**
- Le fichier existe dans app/
- Tu peux l'importer sans erreur
- Toutes les d√©pendances sont r√©solues

---

### ‚úÖ √âtape 5.4 : Cr√©er run.py (script de lancement)

**Ce que ce fichier doit faire :**
- Lancer l'application facilement
- √Ä la racine du projet

**Contenu :**

```python
import uvicorn
from app.config import get_settings

settings = get_settings()

if __name__ == "__main__":
    uvicorn.run(
        "app.main:app",
        host=settings.host,
        port=settings.port,
        reload=settings.debug,
        log_level="info"
    )
```

**Comment lancer l'application :**
```bash
python run.py
```

**Ou directement :**
```bash
uvicorn app.main:app --reload --port 8000
```

**Comment savoir que √ßa marche :**
- Tu vois : "Uvicorn running on http://0.0.0.0:8000"
- Messages de startup s'affichent
- Aucune erreur

---

### ‚úÖ √âtape 5.5 : Tester l'API avec Swagger

**Ce que tu dois faire :**
Tester toutes les routes via l'interface Swagger auto-g√©n√©r√©e.

**√âtapes :**

1. **Lancer l'application :**
```bash
python run.py
```

2. **Ouvrir le navigateur :**
```
http://localhost:8000/docs
```

3. **Tu vois l'interface Swagger avec toutes tes routes**

**Tests √† effectuer dans l'ordre :**

**Test 1 : Initialiser un user**
- Route : POST /api/users/init
- Body : `{"username": "TestUser"}`
- V√©rifier : user cr√©√© avec niveau 0

**Test 2 : Chat avec Ego**
- Route : POST /api/chat
- Body : `{"username": "TestUser", "message": "Salut Ego"}`
- V√©rifier : r√©ponse en fran√ßais, style Blue Lock

**Test 3 : Voir stats**
- Route : GET /api/users/TestUser/stats
- V√©rifier : stats compl√®tes + classement

**Test 4 : G√©n√©rer une mission**
- Route : POST /api/missions/generer
- Body : `{"username": "TestUser", "difficulte": "normale"}`
- V√©rifier : mission cr√©√©e avec deadline

**Test 5 : Voir missions actives**
- Route : GET /api/missions/TestUser/actives
- V√©rifier : la mission appara√Æt

**Test 6 : Compl√©ter mission**
- Route : POST /api/missions/1/completer
- Body : `{"description": "J'ai fait le projet...", "lien_github": "..."}`
- V√©rifier : analyse IA + points gagn√©s + niveau MAJ

**Test 7 : Ajouter comp√©tence**
- Route : POST /api/users/TestUser/competence
- Body : `{"competence": "React"}`
- V√©rifier : comp√©tence ajout√©e

**Test 8 : Voir historique**
- Route : GET /api/chat/TestUser/historique
- V√©rifier : toutes les conversations

**Comment savoir que tout marche :**
- ‚úÖ Chaque route retourne 200 OK
- ‚úÖ Les donn√©es sont coh√©rentes
- ‚úÖ Ego r√©pond avec sa personnalit√©
- ‚úÖ Les stats se mettent √† jour
- ‚úÖ Les missions se cr√©ent et se compl√®tent
- ‚úÖ Aucune erreur 500

**Probl√®mes courants :**
- **422 Unprocessable Entity** : body JSON mal format√©
- **404 Not Found** : route mal √©crite
- **500 Internal Server Error** : erreur dans le code, check les logs
- **Timeout** : API Groq lente, augmente timeout

---

## JOUR 6-7 : FRONTEND SIMPLE (6-8 heures)

### üéØ Objectif
Cr√©er une interface web simple mais fonctionnelle.

---

### ‚úÖ √âtape 6.1 : Cr√©er frontend/index.html

**Ce que cette page doit contenir :**

**Structure HTML :**
```html
<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ego IA Blue Lock</title>
    <link rel="stylesheet" href="styles.css">
</head>
<body>
    <!-- Header -->
    <header>
        <h1>üéØ EGO IA BLUE LOCK</h1>
        <div id="user-info">
            <span id="username-display">Guest</span>
            <span id="level-display">Niveau 0</span>
            <span id="points-display">0 points</span>
            <span id="streak-display">üî• 0 jours</span>
        </div>
    </header>

    <!-- Main Container -->
    <div class="container">
        <!-- Sidebar Stats -->
        <aside class="sidebar">
            <h2>üìä Tes Stats</h2>
            <div id="stats-container">
                <!-- Stats dynamiques ici -->
            </div>

            <h2>üèÜ Classement</h2>
            <div id="classement-container">
                <!-- Classement dynamique ici -->
            </div>
        </aside>

        <!-- Main Content -->
        <main class="main-content">
            <!-- Onglets -->
            <div class="tabs">
                <button class="tab active" data-tab="chat">üí¨ Chat</button>
                <button class="tab" data-tab="missions">üéØ Missions</button>
                <button class="tab" data-tab="soumissions">üì§ Soumettre</button>
            </div>

            <!-- Tab Chat -->
            <div id="tab-chat" class="tab-content active">
                <div id="chat-container">
                    <!-- Messages ici -->
                </div>
                <div class="chat-input">
                    <input type="text" id="message-input" placeholder="Parle √† Ego...">
                    <button id="send-button">Envoyer</button>
                </div>
            </div>

            <!-- Tab Missions -->
            <div id="tab-missions" class="tab-content">
                <button id="generate-mission-btn">üé≤ G√©n√©rer une mission</button>
                <div id="missions-container">
                    <!-- Missions ici -->
                </div>
            </div>

            <!-- Tab Soumissions -->
            <div id="tab-soumissions" class="tab-content">
                <form id="soumission-form">
                    <select id="mission-select">
                        <option>S√©lectionne une mission</option>
                    </select>
                    <textarea id="soumission-description" placeholder="D√©cris ce que tu as fait..."></textarea>
                    <input type="url" id="soumission-github" placeholder="Lien GitHub (optionnel)">
                    <button type="submit">Soumettre</button>
                </form>
                <div id="soumissions-history">
                    <!-- Historique soumissions -->
                </div>
            </div>
        </main>
    </div>

    <script src="app.js"></script>
</body>
</html>
```

**Sections importantes :**
1. **Header** : infos user toujours visibles
2. **Sidebar** : stats et classement
3. **Onglets** : chat, missions, soumissions
4. **Chaque onglet** : contenu sp√©cifique

---

### ‚úÖ √âtape 6.2 : Cr√©er frontend/styles.css

**Ce que le CSS doit faire :**
- Design moderne et clean
- Th√®me Blue Lock (bleu/noir/blanc)
- Responsive (fonctionne sur mobile)
- Animations subtiles

**√âl√©ments de style importants :**

**Variables CSS :**
```css
:root {
    --primary-color: #0066cc;
    --secondary-color: #001a33;
    --accent-color: #ff6600;
    --bg-color: #f5f5f5;
    --text-color: #333;
    --border-color: #ddd;
    --success-color: #28a745;
    --danger-color: #dc3545;
}
```

**Layout :**
- Header fixe en haut
- Container flex : sidebar (30%) + main (70%)
- Chat en bas avec input fixe
- Missions en cartes (grid)

**Composants stylis√©s :**
- Messages du chat (user √† droite, ego √† gauche)
- Cartes de missions avec statut color√©
- Badges pour niveau et streak
- Boutons avec hover effects
- Formulaires propres

**Animations :**
- Fade in pour nouveaux messages
- Pulse pour notifications
- Smooth scroll
- Transitions sur hover

**Comment structurer :**
```css
/* Reset et base */
* { margin: 0; padding: 0; box-sizing: border-box; }
body { font-family: 'Segoe UI', sans-serif; }

/* Header */
header { ... }

/* Layout */
.container { display: flex; }
.sidebar { width: 30%; }
.main-content { width: 70%; }

/* Chat */
#chat-container { ... }
.message { ... }
.message.user { ... }
.message.ego { ... }

/* Missions */
.mission-card { ... }
.mission-card.active { ... }
.mission-card.completed { ... }

/* Forms */
form { ... }
input, textarea, select { ... }
button { ... }

/* Responsive */
@media (max-width: 768px) {
    .container { flex-direction: column; }
    .sidebar, .main-content { width: 100%; }
}
```

---

### ‚úÖ √âtape 6.3 : Cr√©er frontend/app.js

**Ce que ce fichier doit faire :**
- G√©rer toutes les interactions avec l'API
- Mettre √† jour le DOM dynamiquement
- G√©rer les onglets
- Sauvegarder l'username en localStorage

**Structure globale :**

```javascript
// Configuration
const API_URL = 'http://localhost:8000/api';
let currentUser = null;

// Au chargement de la page
document.addEventListener('DOMContentLoaded', init);

async function init() {
    // 1. Demander username ou r√©cup√©rer du localStorage
    // 2. Initialiser user via API
    // 3. Charger stats
    // 4. Charger missions
    // 5. Charger historique chat
    // 6. Setup event listeners
}
```

**Fonctions principales √† cr√©er :**

**1. Gestion utilisateur :**
```javascript
async function initUser(username) {
    // POST /api/users/init
    // Sauver dans localStorage
    // Mettre √† jour l'affichage
}

async function loadUserStats() {
    // GET /api/users/{username}/stats
    // Afficher stats dans sidebar
    // Afficher classement
}
```

**2. Gestion chat :**
```javascript
async function sendMessage() {
    const message = document.getElementById('message-input').value;

    // Afficher message user imm√©diatement
    appendMessage(message, 'user');

    // POST /api/chat
    const response = await fetch(`${API_URL}/chat`, {
        method: 'POST',
        headers: {'Content-Type': 'application/json'},
        body: JSON.stringify({
            username: currentUser.username,
            message: message
        })
    });

    const data = await response.json();

    // Afficher r√©ponse Ego
    appendMessage(data.reponse_ego, 'ego');

    // Clear input
    document.getElementById('message-input').value = '';
}

function appendMessage(text, sender) {
    const container = document.getElementById('chat-container');
    const messageDiv = document.createElement('div');
    messageDiv.className = `message ${sender}`;
    messageDiv.textContent = text;
    container.appendChild(messageDiv);
    container.scrollTop = container.scrollHeight;
}
```

**3. Gestion missions :**
```javascript
async function generateMission() {
    const difficulte = prompt('Difficult√© (facile/normale/difficile):', 'normale');

    // POST /api/missions/generer
    const response = await fetch(`${API_URL}/missions/generer`, {
        method: 'POST',
        headers: {'Content-Type': 'application/json'},
        body: JSON.stringify({
            username: currentUser.username,
            difficulte: difficulte
        })