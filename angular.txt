# üì± GUIDE COMPLET ANGULAR 19 - FRONTEND CORRECTEUR AUTOMATIQUE
## Version Sans Code - Architecture Professionnelle avec Signals

---

## üéØ OBJECTIF FINAL
Cr√©er un frontend Angular 19 moderne qui :
1. Communique avec votre API FastAPI existante
2. Utilise les Signals pour le state management
3. Applique une architecture propre et scalable
4. Permet l'upload de fichiers et l'affichage des r√©sultats
5. G√©n√®re des rapports PDF des corrections

---

## üìö NOUVEAUT√âS ANGULAR 19 (√Ä CONNA√éTRE)

### ‚ú® Standalone Components (Par d√©faut)
**Ce que c'est :**
- Plus besoin de cr√©er des modules NgModule
- Chaque composant s'importe directement
- Plus simple et plus moderne

**Avantages :**
- Moins de fichiers √† g√©rer
- Code plus clair
- Chargement plus rapide

---

### ‚ö° Signals (State Management Natif)
**Ce que c'est :**
- Syst√®me de r√©activit√© int√©gr√© √† Angular
- Remplace les Observables pour certains cas
- Plus simple que RxJS pour g√©rer l'√©tat

**Concepts cl√©s :**
- **signal()** : Cr√©e une valeur r√©active
- **computed()** : Calcule automatiquement une valeur d√©riv√©e
- **effect()** : R√©agit aux changements de signals

**Quand utiliser :**
- State local d'un composant ‚Üí signal()
- Calculs bas√©s sur plusieurs signals ‚Üí computed()
- Actions √† d√©clencher sur changement ‚Üí effect()

---

### üîÄ Nouvelle Syntaxe de Contr√¥le (Control Flow)
**Ce que c'est :**
- Nouvelle fa√ßon d'√©crire if, for, switch dans les templates
- Plus lisible que les directives *ngIf, *ngFor

**Exemples :**
- `@if (condition) { ... }` remplace `*ngIf`
- `@for (item of items; track item.id) { ... }` remplace `*ngFor`
- `@switch (value) { @case ('a') { ... } }` remplace `*ngSwitch`

---

### üíâ inject() Function
**Ce que c'est :**
- Nouvelle fa√ßon d'injecter des d√©pendances
- Plus besoin du constructor pour certains cas
- Code plus compact

**Avantages :**
- Moins de boilerplate
- Plus fonctionnel
- Plus moderne

---

### üéØ Route Inputs
**Ce que c'est :**
- Les param√®tres de route deviennent des inputs automatiques
- Plus besoin d'injecter ActivatedRoute
- Plus simple et type-safe

---

### ‚è≥ @defer (Lazy Loading Am√©lior√©)
**Ce que c'est :**
- Charge des composants uniquement quand n√©cessaire
- Conditions multiples : viewport, interaction, timer
- Gestion automatique des √©tats loading/placeholder/error

---

## üèóÔ∏è ARCHITECTURE DU PROJET

### Principe : Separation of Concerns

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ     PR√âSENTATION (Components)            ‚îÇ
‚îÇ  - Affichage uniquement                  ‚îÇ
‚îÇ  - Re√ßoit donn√©es via Input              ‚îÇ
‚îÇ  - √âmet √©v√©nements via Output            ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
            ‚îÇ
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ     SMART COMPONENTS (Containers)        ‚îÇ
‚îÇ  - G√®re la logique m√©tier                ‚îÇ
‚îÇ  - Utilise les services et stores        ‚îÇ
‚îÇ  - Orchestre les composants dumb         ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
            ‚îÇ
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ     STATE MANAGEMENT (Stores)            ‚îÇ
‚îÇ  - G√®re l'√©tat global avec Signals       ‚îÇ
‚îÇ  - √âtat immutable                        ‚îÇ
‚îÇ  - Computed pour d√©rivations             ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
            ‚îÇ
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ     SERVICES (Business Logic)            ‚îÇ
‚îÇ  - Communication API                     ‚îÇ
‚îÇ  - Logique m√©tier r√©utilisable           ‚îÇ
‚îÇ  - Transformations de donn√©es            ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
            ‚îÇ
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ     API LAYER (HTTP)                     ‚îÇ
‚îÇ  - Appels HTTP vers FastAPI              ‚îÇ
‚îÇ  - Gestion des erreurs                   ‚îÇ
‚îÇ  - Intercepteurs                         ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

---

## üöÄ JOUR 1 : INSTALLATION ET CONFIGURATION (2-3 heures)

### ‚úÖ √âtape 1.1 : V√©rifier Node.js
**Ce que tu fais :**
- Ouvre un terminal
- Tape : `node --version`
- Tu dois voir : v18.19 ou v20.11 minimum

**Si pas install√© :**
- Va sur nodejs.org
- T√©l√©charge la version LTS (Long Term Support)
- Installe en suivant l'assistant

**Comment savoir que √ßa marche :**
- `node --version` affiche la version
- `npm --version` affiche aussi une version

---

### ‚úÖ √âtape 1.2 : Installer Angular CLI 19
**Ce que tu fais :**
- Dans le terminal, tape : `npm install -g @angular/cli@latest`
- Attends 1-2 minutes (t√©l√©chargement)

**Ce qui se passe :**
- Angular CLI s'installe globalement sur ton ordinateur
- Tu pourras cr√©er des projets Angular partout

**Comment savoir que √ßa marche :**
- Tape : `ng version`
- Tu dois voir : Angular CLI: 19.x.x

**Si erreur de permissions (Mac/Linux) :**
- Ajoute `sudo` devant : `sudo npm install -g @angular/cli@latest`

---

### ‚úÖ √âtape 1.3 : Cr√©er le projet Angular (S√âPAR√â du backend)
**Ce que tu fais :**
- Navigue vers le dossier parent de ton projet Python
- Exemple : Si ton backend est dans `C:\Users\jacke\PycharmProjects\fastApiProject`
- Va dans `C:\Users\jacke\PycharmProjects\`
- Tape : `ng new correcteur-frontend`

**Questions √† r√©pondre :**
1. **Would you like to add Angular routing?** ‚Üí Tape `Y` (Oui)
2. **Which stylesheet format?** ‚Üí Choisis `SCSS` (avec les fl√®ches, Enter)
3. **Enable Server-Side Rendering?** ‚Üí Tape `N` (Non, pas besoin)

**Ce qui se passe :**
- Angular cr√©e un nouveau dossier `correcteur-frontend`
- Installe toutes les d√©pendances (2-3 minutes)
- Configure le projet

**Comment savoir que √ßa marche :**
- Un dossier `correcteur-frontend` appara√Æt
- Dedans, tu vois : `src/`, `angular.json`, `package.json`, etc.

---

### ‚úÖ √âtape 1.4 : Lancer le projet pour la premi√®re fois
**Ce que tu fais :**
- Entre dans le dossier : `cd correcteur-frontend`
- Lance le serveur : `ng serve`
- Attends que √ßa compile (30 secondes)

**Ce qui se passe :**
- Le serveur de d√©veloppement d√©marre
- Tu vois : "‚úî Browser application bundle generation complete"
- Puis : "Local: http://localhost:4200/"

**Comment savoir que √ßa marche :**
- Ouvre ton navigateur
- Va sur : http:/code/localhost:4200
- Tu vois la page d'accueil Angular (avec le logo)
- C'est bon, Angular fonctionne !

**Pour arr√™ter le serveur :**
- Dans le terminal, fais : Ctrl+C

---

## üìÅ JOUR 2 : STRUCTURE DES DOSSIERS (2-3 heures)

### ‚úÖ √âtape 2.1 : Comprendre la structure initiale
**Ce qui existe d√©j√† :**

```
correcteur-frontend/
‚îú‚îÄ‚îÄ src/
‚îÇ   ‚îú‚îÄ‚îÄ app/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ app.component.ts     ‚Üê Composant racine
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ app.config.ts        ‚Üê Configuration app
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ app.routes.ts        ‚Üê Routes (navigation)
‚îÇ   ‚îú‚îÄ‚îÄ assets/                  ‚Üê Images, ic√¥nes
‚îÇ   ‚îú‚îÄ‚îÄ environments/            ‚Üê Configuration env
‚îÇ   ‚îî‚îÄ‚îÄ styles.scss              ‚Üê Styles globaux
‚îú‚îÄ‚îÄ angular.json                 ‚Üê Config Angular
‚îú‚îÄ‚îÄ package.json                 ‚Üê D√©pendances npm
‚îî‚îÄ‚îÄ tsconfig.json               ‚Üê Config TypeScript
```

**√Ä retenir :**
- `src/app/` : C'est l√† que tu vas travailler
- `app.component.ts` : Le composant principal (garde-le)
- `app.routes.ts` : Tu vas y d√©finir tes routes
- `environments/` : Pour les URLs de l'API (dev vs prod)

---

### ‚úÖ √âtape 2.2 : Cr√©er la structure de dossiers professionnelle
**Ce que tu fais :**
Dans `src/app/`, cr√©e ces dossiers (clic droit > New > Directory) :

**1. Dossier `core/`** (Services globaux, singletons)
- `core/services/` ‚Üí Pour api.service, notification.service
- `core/guards/` ‚Üí Pour la protection des routes (plus tard)
- `core/interceptors/` ‚Üí Pour intercepter les requ√™tes HTTP
- `core/config/` ‚Üí Pour les constantes et configurations

**2. Dossier `shared/`** (Composants r√©utilisables)
- `shared/components/ui/` ‚Üí Boutons, cartes, spinners
- `shared/components/layout/` ‚Üí Navbar, footer, sidebar
- `shared/directives/` ‚Üí Directives custom (drag & drop)
- `shared/pipes/` ‚Üí Pipes custom (formatage)
- `shared/models/` ‚Üí Interfaces communes

**3. Dossier `features/`** (Modules fonctionnels)
- `features/dashboard/` ‚Üí Page d'accueil
- `features/session/` ‚Üí Gestion des sessions
- `features/correction/` ‚Üí D√©tails des corrections

**Structure finale attendue :**
```
src/app/
‚îú‚îÄ‚îÄ core/
‚îÇ   ‚îú‚îÄ‚îÄ services/
‚îÇ   ‚îú‚îÄ‚îÄ guards/
‚îÇ   ‚îú‚îÄ‚îÄ interceptors/
‚îÇ   ‚îî‚îÄ‚îÄ config/
‚îú‚îÄ‚îÄ shared/
‚îÇ   ‚îú‚îÄ‚îÄ components/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ ui/
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ layout/
‚îÇ   ‚îú‚îÄ‚îÄ directives/
‚îÇ   ‚îú‚îÄ‚îÄ pipes/
‚îÇ   ‚îî‚îÄ‚îÄ models/
‚îú‚îÄ‚îÄ features/
‚îÇ   ‚îú‚îÄ‚îÄ dashboard/
‚îÇ   ‚îú‚îÄ‚îÄ session/
‚îÇ   ‚îî‚îÄ‚îÄ correction/
‚îú‚îÄ‚îÄ app.component.ts
‚îú‚îÄ‚îÄ app.config.ts
‚îî‚îÄ‚îÄ app.routes.ts
```

**Comment savoir que √ßa marche :**
- Tous ces dossiers existent dans `src/app/`
- Ils sont vides pour l'instant (c'est normal)

---

### ‚úÖ √âtape 2.3 : Installer les d√©pendances UI
**Ce que tu fais :**
Choisis UNE de ces options (je recommande PrimeNG) :

**Option 1 : PrimeNG (Recommand√©)**
```
npm install primeng primeicons
```
- Biblioth√®que UI riche
- Composants pr√™ts √† l'emploi
- Bien document√©e

**Option 2 : Angular Material**
```
ng add @angular/material
```
- Officiel Google
- Design Material Design
- Moins de composants avanc√©s

**Ce qui se passe :**
- Les packages se t√©l√©chargent (1-2 minutes)
- Les d√©pendances s'ajoutent √† `package.json`

**Comment savoir que √ßa marche :**
- Aucune erreur rouge
- Dans `package.json`, tu vois les nouvelles d√©pendances

---

### ‚úÖ √âtape 2.4 : Installer les utilitaires
**Ce que tu fais :**
Dans le terminal, tape :
```
npm install date-fns chart.js ng2-charts file-saver
npm install @types/file-saver --save-dev
```

**Ce que c'est :**
- `date-fns` : Manipulation facile des dates
- `chart.js` : Pour les graphiques de statistiques
- `ng2-charts` : Wrapper Angular pour Chart.js
- `file-saver` : Pour t√©l√©charger les PDF

**Comment savoir que √ßa marche :**
- Installation sans erreur
- Les packages apparaissent dans `package.json`

---

## üåê JOUR 3 : CONFIGURATION ENVIRONNEMENTS (2 heures)

### ‚úÖ √âtape 3.1 : Configurer les environnements
**Ce que tu fais :**
Dans `src/environments/`, tu as d√©j√† :
- `environment.ts` (pour le d√©veloppement)
- `environment.prod.ts` (pour la production)

**Dans `environment.ts`, d√©finis :**
- `production`: false (c'est du dev)
- `apiUrl`: 'http://localhost:8001' (ton API FastAPI)
- `apiTimeout`: 30000 (30 secondes)
- `maxFileSize`: 10485760 (10 MB en bytes)
- `supportedFormats`: ['.pdf', '.jpg', '.png']

**Dans `environment.prod.ts`, d√©finis :**
- `production`: true
- `apiUrl`: 'https://ton-api-production.com' (√† changer plus tard)
- Les m√™mes autres param√®tres

**Pourquoi c'est important :**
- En dev, tu testes sur localhost
- En prod, tu pointeras vers ton serveur r√©el
- Angular switche automatiquement selon le build

**Comment savoir que √ßa marche :**
- Les deux fichiers existent
- Ils contiennent les bonnes URLs

---

### ‚úÖ √âtape 3.2 : Configurer TypeScript (Paths aliases)
**Ce que tu fais :**
Ouvre `tsconfig.json` √† la racine du projet.

**Ajoute dans `compilerOptions` :**
- `"strict": true` (mode strict, plus s√ªr)
- `"strictNullChecks": true` (√©vite les null/undefined)
- `"paths"`: (pour importer facilement)
  - `"@core/*"`: `["src/app/core/*"]`
  - `"@shared/*"`: `["src/app/shared/*"]`
  - `"@features/*"`: `["src/app/features/*"]`
  - `"@env/*"`: `["src/environments/*"]`

**Pourquoi c'est utile :**
- Au lieu d'√©crire : `import { ApiService } from '../../../core/services/api.service'`
- Tu √©cris : `import { ApiService } from '@core/services/api.service'`
- Plus propre, moins d'erreurs

**Comment savoir que √ßa marche :**
- Le fichier est sauvegard√©
- Aucune erreur dans le terminal

---

## üîÑ JOUR 4-5 : STATE MANAGEMENT AVEC SIGNALS (4-6 heures)

### ‚úÖ √âtape 4.1 : Comprendre le pattern Store avec Signals
**Architecture du Store :**

**Un Store, c'est quoi ?**
- Une classe qui contient l'√©tat global de ton app
- Utilise des Signals pour la r√©activit√©
- Toutes les donn√©es passent par le store

**Structure d'un Store :**
1. **State priv√©** (signal) : Les donn√©es brutes
2. **Selectors publics** (computed) : Les donn√©es expos√©es en lecture seule
3. **Actions** (m√©thodes) : Pour modifier l'√©tat

**Avantages :**
- √âtat centralis√© (pas de props drilling)
- R√©activit√© automatique (les composants se mettent √† jour tout seuls)
- Pr√©visible (un seul endroit pour les donn√©es)
- Debuggable (tu vois tout ce qui se passe)

---

### ‚úÖ √âtape 4.2 : Cr√©er le mod√®le de Session
**Ce que tu fais :**
Dans `features/session/`, cr√©e un dossier `models/`.
Dedans, cr√©e un fichier : `session.model.ts`

**Ce fichier doit d√©finir :**

**Interface Session :**
- id: string (l'ID de session de ton API)
- status: 'copies_uploaded' | 'epreuve_uploaded' | 'ready_to_correct' | 'correcting' | 'completed' | 'error'
- epreuve: objet avec (filename, path) ou null
- copies: tableau d'objets avec (nom_eleve, classe, texte_complet, pages_sources)
- correction: objet avec (filename, path) ou null
- created_at: string (date ISO)
- results: tableau de r√©sultats ou null

**Interface Student (pour les copies) :**
- nom_eleve: string
- classe: string
- texte_complet: string
- pages_sources: number[]

**Interface CorrectionResult :**
- nom_eleve: string
- classe: string
- note_finale: number
- details: tableau d'objets question/r√©sultat

**Pourquoi c'est important :**
- TypeScript v√©rifie les types √† la compilation
- Autocomplete dans VS Code
- Moins d'erreurs

**Comment savoir que √ßa marche :**
- Le fichier existe
- Tu peux l'importer sans erreur

---

### ‚úÖ √âtape 4.3 : Cr√©er le SessionStore
**Ce que tu fais :**
Dans `features/session/`, cr√©e un dossier `store/`.
Dedans, cr√©e : `session.store.ts`

**Ce que ce Store doit contenir :**

**1. Interface SessionState (l'√©tat complet) :**
- sessions: tableau de Session
- currentSession: Session ou null
- loading: boolean
- error: string ou null

**2. La classe SessionStore avec :**

**a) Signal priv√© d'√©tat :**
- Un signal qui contient tout le SessionState
- √âtat initial : tout vide/false/null

**b) Selectors publics (computed) :**
- sessions: retourne toutes les sessions
- currentSession: retourne la session active
- loading: retourne l'√©tat de chargement
- error: retourne l'erreur √©ventuelle
- sessionCount: calcule le nombre de sessions
- activeSessions: filtre les sessions non termin√©es
- completedSessions: filtre les sessions termin√©es

**c) Actions (m√©thodes pour modifier) :**
- setSessions(sessions): remplace toutes les sessions
- addSession(session): ajoute une nouvelle session
- setCurrentSession(session): d√©finit la session active
- updateSessionStatus(id, status): change le statut d'une session
- setLoading(loading): active/d√©sactive le loading
- setError(error): d√©finit une erreur
- reset(): remet tout √† z√©ro

**Architecture interne de chaque action :**
1. Prendre le state actuel
2. Le cloner (immutabilit√© !)
3. Modifier la copie
4. Mettre √† jour le signal avec la nouvelle valeur

**Pourquoi cette architecture :**
- Immutabilit√© : l'ancien state n'est jamais modifi√© directement
- Tra√ßabilit√© : on voit chaque changement
- Performance : Angular d√©tecte facilement les changements

**Comment savoir que √ßa marche :**
- Le fichier existe
- Tu peux l'injecter dans un composant sans erreur

---

### ‚úÖ √âtape 4.4 : Utiliser le Store dans un composant (Test)
**Ce que tu fais :**
Dans `app.component.ts` (juste pour tester), injecte le store.

**Ce que tu dois faire :**
1. Importer SessionStore
2. L'injecter avec inject()
3. Cr√©er des propri√©t√©s qui utilisent les selectors
4. Dans le template, afficher le nombre de sessions

**Ce qui doit se passer :**
- Le composant r√©agit automatiquement aux changements du store
- Pas besoin de subscribe()
- Les computed se recalculent automatiquement

**Comment tester :**
1. Lance `ng serve`
2. Ouvre la console du navigateur (F12)
3. Dans le composant, ajoute une session de test
4. Le template se met √† jour automatiquement

**Comment savoir que √ßa marche :**
- Le nombre de sessions s'affiche
- √áa change quand tu modifies le store
- Aucune erreur dans la console

---

## üåê JOUR 6-7 : SERVICES ET API (6-8 heures)

### ‚úÖ √âtape 6.1 : Cr√©er le service API central
**Ce que tu fais :**
Dans `core/services/`, cr√©e : `api.service.ts`

**Ce que ce service doit faire :**

**Configuration :**
- Injectable en "root" (singleton global)
- Injecter HttpClient d'Angular
- R√©cup√©rer l'URL de base depuis environment

**M√©thodes √† cr√©er :**

**1. get<T>(endpoint: string) :**
- Fait un GET vers baseUrl + endpoint
- Ajoute un timeout (30 secondes)
- R√©essaie 1 fois en cas d'√©chec
- G√®re les erreurs avec handleError

**2. post<T>(endpoint: string, data: any) :**
- Fait un POST vers baseUrl + endpoint
- Envoie les donn√©es en JSON
- G√®re les erreurs

**3. postFile<T>(endpoint: string, formData: FormData) :**
- POST sp√©cial pour les uploads de fichiers
- Accepte du FormData (pas du JSON)
- Timeout plus long (60 secondes)
- G√®re les erreurs

**4. put<T>(endpoint: string, data: any) :**
- Met √† jour des donn√©es existantes
- G√®re les erreurs

**5. delete<T>(endpoint: string) :**
- Supprime une ressource
- G√®re les erreurs

**6. handleError (m√©thode priv√©e) :**
- Re√ßoit une erreur HTTP
- D√©termine si c'est une erreur client ou serveur
- Log l'erreur dans la console
- Retourne un Observable d'erreur

**Pourquoi centraliser :**
- √âvite de r√©p√©ter le code HTTP partout
- Gestion d'erreur uniforme
- Facile √† debugger
- Un seul endroit √† modifier si l'API change

**Comment savoir que √ßa marche :**
- Le service existe
- Tu peux l'injecter sans erreur
- Les m√©thodes sont typ√©es correctement

---

### ‚úÖ √âtape 6.2 : Cr√©er le SessionService (Feature-specific)
**Ce que tu fais :**
Dans `features/session/services/`, cr√©e : `session.service.ts`

**Ce que ce service doit faire :**

**Configuration :**
- Injectable en "root"
- Injecter ApiService
- Injecter SessionStore

**M√©thodes √† cr√©er :**

**1. uploadCopiesBundle(file: File) :**
- Cr√©e un FormData
- Ajoute le fichier dedans
- Active le loading dans le store
- Appelle api.postFile('upload-copies-bundle', formData)
- Quand √ßa r√©ussit :
  - Ajoute la session au store
  - D√©finit comme session courante
  - D√©sactive le loading
- Si erreur :
  - Stocke l'erreur dans le store
  - D√©sactive le loading

**2. uploadEpreuve(sessionId: string, file: File) :**
- Cr√©e un FormData
- Appelle api.postFile(`upload-epreuve/${sessionId}`, formData)
- Met √† jour le status de la session dans le store

**3. uploadCorrection(sessionId: string, file: File) :**
- M√™me principe que uploadEpreuve
- Endpoint : `upload-correction/${sessionId}`
- Status final : 'ready_to_correct'

**4. startCorrection(sessionId: string) :**
- Appelle api.post(`corriger/${sessionId}`, {})
- Met le status √† 'correcting'
- Retourne les r√©sultats

**5. getAllSessions() :**
- Appelle api.get('sessions')
- Transform la r√©ponse (dictionnaire ‚Üí tableau)
- Stocke dans le store

**6. downloadPDF(sessionId: string) :**
- Appelle l'endpoint export-pdf
- Retourne un Blob (fichier binaire)
- Le composant s'occupera de le t√©l√©charger

**Pourquoi ce service :**
- Encapsule la logique m√©tier des sessions
- Fait le lien entre l'API et le Store
- Les composants n'ont pas besoin de conna√Ætre l'API

**Comment savoir que √ßa marche :**
- Le service existe
- Toutes les m√©thodes retournent des Observables
- Tu peux l'injecter dans un composant

---

### ‚úÖ √âtape 6.3 : Configurer les intercepteurs HTTP
**Ce que tu fais :**
Dans `core/interceptors/`, cr√©e : `auth.interceptor.ts`

**Ce que cet intercepteur doit faire :**
- Intercepter toutes les requ√™tes HTTP sortantes
- Ajouter des headers communs :
  - Content-Type: application/json (si n√©cessaire)
  - Authorization: Bearer token (si tu ajoutes l'auth plus tard)
- Logger les requ√™tes en mode dev

**Dans `core/interceptors/`, cr√©e aussi : `error.interceptor.ts`**

**Ce qu'il doit faire :**
- Intercepter toutes les r√©ponses d'erreur
- Selon le code d'erreur :
  - 401 : Non autoris√© ‚Üí Rediriger vers login
  - 404 : Non trouv√© ‚Üí Afficher notification
  - 500 : Erreur serveur ‚Üí Afficher notification
  - Timeout : Afficher "Le serveur met trop de temps"
- Retourner l'erreur pour que le service puisse la g√©rer aussi

**Comment les activer :**
Dans `app.config.ts`, ajoute-les aux providers HTTP.

**Pourquoi c'est utile :**
- Gestion centralis√©e des erreurs
- Logs automatiques
- Headers automatiques
- Moins de code dans les services

**Comment savoir que √ßa marche :**
- Les intercepteurs existent
- Ils sont enregistr√©s dans app.config.ts
- Les requ√™tes passent par eux (v√©rifie dans l'onglet Network du navigateur)

---

## üß© JOUR 8-10 : COMPOSANTS (8-12 heures)

### ‚úÖ √âtape 8.1 : Comprendre Smart vs Dumb Components

**DUMB Components (Presentational) :**
**Ce que c'est :**
- Composants qui affichent uniquement
- Re√ßoivent des donn√©es via @Input()
- √âmettent des √©v√©nements via @Output()
- Pas de logique m√©tier
- Pas d'appel aux services
- R√©utilisables partout

**Exemple : StatsCard**
- Input : title, value, icon, color
- Output : aucun (juste affichage)
- Utilisation : Afficher une statistique

**SMART Components (Container) :**
**Ce que c'est :**
- Composants qui orchestrent
- Utilisent les services
- Lisent et modifient le store
- G√®rent la logique m√©tier
- Passent les donn√©es aux composants dumb

**Exemple : Dashboard**
- Charge les donn√©es via SessionService
- Lit le store
- Passe les donn√©es √† StatsCard
- G√®re les clics et navigation

**Pourquoi cette s√©paration :**
- Code plus propre
- Composants dumb r√©utilisables
- Facile √† tester
- Logique centralis√©e dans les smart

---

### ‚úÖ √âtape 8.2 : Cr√©er les composants UI (Dumb)
**Ce que tu fais :**
G√©n√®re ces composants avec Angular CLI :

```
ng generate component shared/components/ui/button --standalone
ng generate component shared/components/ui/card --standalone
ng generate component shared/components/ui/spinner --standalone
ng generate component shared/components/ui/progress-bar --standalone
ng generate component shared/components/ui/file-uploader --standalone
```

**Pour chaque composant dumb :**

**1. button.component.ts :**
- @Input() label: string
- @Input() type: 'primary' | 'secondary' | 'danger'
- @Input() disabled: boolean
- @Input() loading: boolean
- @Output() clicked: EventEmitter
- Template : Un bouton stylis√© qui √©met l'√©v√©nement au clic

**2. card.component.ts :**
- @Input() title: string
- @Input() subtitle: string optionnel
- Template : Une carte avec titre et ng-content pour le contenu

**3. spinner.component.ts :**
- @Input() size: 'small' | 'medium' | 'large'
- @Input() color: string
- Template : Un loader anim√© (CSS)

**4. progress-bar.component.ts :**
- @Input() value: number (0-100)
- @Input() color: string
- Template : Une barre de progression

**5. file-uploader.component.ts :**
- @Input() accept: string ('.pdf,.jpg,.png')
- @Input() maxSize: number
- @Input() multiple: boolean
- @Output() filesSelected: EventEmitter<File[]>
- Template : Zone de drag & drop + bouton "Parcourir"
- Validation des fichiers (taille, format)

**Comment savoir que √ßa marche :**
- Les composants existent dans `shared/components/ui/`
- Chacun a son .ts, .html, .scss
- Tu peux les importer dans un autre composant

---

### ‚úÖ √âtape 8.3 : Cr√©er les composants Layout
**Ce que tu fais :**
```
ng generate component shared/components/layout/navbar --standalone
ng generate component shared/components/layout/sidebar --standalone
ng generate component shared/components/layout/footer --standalone
```

**navbar.component.ts :**
- Affiche le logo de l'app
- Menu de navigation (Dashboard, Sessions, Aide)
- Bouton de profil (optionnel)
- Template : Header avec liens de navigation

**sidebar.component.ts :**
- Liste des sections de l'app
- Highlight de la section active
- Template : Menu lat√©ral (optionnel, si tu veux)

**footer.component.ts :**
- Copyright
- Liens utiles
- Version de l'app
- Template : Footer simple

**Comment savoir que √ßa marche :**
- Les composants existent
- Tu peux les importer dans app.component

---

### ‚úÖ √âtape 8.4 :
‚ùå session.service.ts (√Ä FAIRE EN PREMIER)
‚ùå notification.service.ts (Pour afficher les messages)
```

#### **PRIORIT√â 2 : Composants UI R√©utilisables**
```
‚ùå button.component.ts
‚ùå card.component.ts
‚ùå spinner.component.ts
‚ùå file-uploader.component.ts (CRUCIAL pour ton app)
‚ùå progress-bar.component.ts